<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Fri Jun 28 13:01:56 CDT 2002 -->
<TITLE>
Path
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="Path";
}
</SCRIPT>
<BODY BGCOLOR="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../glguerin/io/FilePathname.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Path.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
glguerin.io</FONT>
<BR>
Class  Path</H2>
<PRE>
java.lang.Object
  |
  +--<B>glguerin.io.Path</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../glguerin/io/FilePathname.html">FilePathname</A></DD>
</DL>
<HR>
<DL>
<DT>public class <B>Path</B><DT>extends java.lang.Object</DL>

<P>
A Path is an ordered sequence of String parts, often representing a progressively
 more qualified name-sequence (such as a file-name), or an ordered series of elements
 (such as a search-path).
 The parts are randomly retrievable by index, 
 or retrievable as a String array,
 or can be assembled into a single String with embedded separators, 
 Parts are not randomly accessible for alteration.
 A Path's parts can only be altered altered at the tail end of the sequence, i.e. by appending
 or trimming the last part.  Eliminating random-access alteration, such as in java.util.Vector, 
 makes altering a Path substantially more efficient.
<p>
 The order/sequence of the parts can be reversed by reverse().
 This is useful when you need to build a Path in reverse order from the eventual
 ordered sequence you want.  You can also use it to prepend a part, invoking
 the methods as: reverse(), append(newPart), reverse().
 I'm sure you can think of other uses.
<p>
 The class Path will most likely used as a base-class for more specialized classes,
 such as one to specifically represent a file-name path (FilePathname).  One should also note
 that a Path sub-class can easily represent other ordered sequences, such as a class-path or
 a DNS-name.
<p>
 No methods in this class are synchronized, even when a thread-safety issue
 is known to exist.
 If you need thread-safety you must provide it yourself.  
 The most common uses of this class do not involve shared access
 by multiple threads, so synchronizing seemed like a time-wasting overkill.
 If you disagree, you have the source...
<P>

<P>
<DL>
<DT><B>Author:</B><DD>Gregory Guerin</DD>
</DD>
<DT><B>See Also:</B><DD><A HREF="../../glguerin/io/FilePathname.html"><CODE>FilePathname</CODE></A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#Path()">Path</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create with no parts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#Path(int)">Path</A></B>(int&nbsp;partCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create with initial space for given part-count, but no actual parts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#Path(java.lang.String[])">Path</A></B>(java.lang.String[]&nbsp;parts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create with initial parts.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#append(java.lang.String)">append</A></B>(java.lang.String&nbsp;toAppend)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Append the given part String, growing the internal storage as needed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#appendAll(java.lang.String[])">appendAll</A></B>(java.lang.String[]&nbsp;toAppend)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Append all the items in toAppend using the append(String) method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.StringBuffer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#buildPath(char, boolean, boolean)">buildPath</A></B>(char&nbsp;between,
          boolean&nbsp;initially,
          boolean&nbsp;useEscapes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a StringBuffer holding all the parts, placing the given char between the parts,
 and also placing it initially if the flag is true.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#clear()">clear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clear all the parts, but don't reduce the current capacity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#ensureCapacity(int)">ensureCapacity</A></B>(int&nbsp;partCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ensure the given capacity, growing the array as needed while preserving current contents.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#equals(java.lang.Object)">equals</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Override Object.equals(Object), returning true if every unescaped
 part in this instance String.equals() every unescaped part in other.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#getPart(int, boolean)">getPart</A></B>(int&nbsp;index,
        boolean&nbsp;useEscapes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the indexed part with the given escaping applied, or null if out of range.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#getParts(boolean)">getParts</A></B>(boolean&nbsp;useEscapes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a new array holding all the parts, with escapes applied according
 to the given flag.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#getPath()">getPath</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a String consisting of the Path parts separated by an internally determined
 separator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#hashCode()">hashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Override Object.hashCode(), returning the partCount().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#isAcceptablePart(java.lang.String)">isAcceptablePart</A></B>(java.lang.String&nbsp;part)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return true if the given String is acceptable to be added as a part.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#last()">last</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the last part, or null if no parts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#part(int)">part</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the indexed part without escaping it, or null if out of range.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#partCount()">partCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the current part-count.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#reverse()">reverse</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reverse the order of the parts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#set(java.lang.String[])">set</A></B>(java.lang.String[]&nbsp;toCopy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clear all the parts, then append the given Strings by calling appendAll( String[] ).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#setFrom(java.lang.String, char)">setFrom</A></B>(java.lang.String&nbsp;path,
        char&nbsp;sep)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Split the given String into parts where indicated by the given separator char,
 assigning them as the parts of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#setPath(java.lang.String)">setPath</A></B>(java.lang.String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the parts from the given String, separated by some internally determined
 separator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#split(java.lang.String, char)">split</A></B>(java.lang.String&nbsp;path,
      char&nbsp;sep)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Split a String representing a path-like sequence into individual
 parts where indicated by the given separator char.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#swap(java.lang.String)">swap</A></B>(java.lang.String&nbsp;toSwap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swap the given String with the last part, using trim() and append().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#toEscapedForm(java.lang.String)">toEscapedForm</A></B>(java.lang.String&nbsp;toTransform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transform the given String to an escaped form, whatever that may be.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#toLiteralForm(java.lang.String)">toLiteralForm</A></B>(java.lang.String&nbsp;toTransform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transform the given String to a literal (unescaped) form, whatever that may be.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Override Object.toString(), returning the getPath() value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../glguerin/io/Path.html#trim()">trim</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trim the most recently added part, and return it.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, finalize, getClass, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Path()"><!-- --></A><H3>
Path</H3>
<PRE>
public <B>Path</B>()</PRE>
<DL>
<DD>Create with no parts.
<P>
</DL>
<HR>

<A NAME="Path(int)"><!-- --></A><H3>
Path</H3>
<PRE>
public <B>Path</B>(int&nbsp;partCount)</PRE>
<DL>
<DD>Create with initial space for given part-count, but no actual parts.
<P>
</DL>
<HR>

<A NAME="Path(java.lang.String[])"><!-- --></A><H3>
Path</H3>
<PRE>
public <B>Path</B>(java.lang.String[]&nbsp;parts)</PRE>
<DL>
<DD>Create with initial parts.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="split(java.lang.String, char)"><!-- --></A><H3>
split</H3>
<PRE>
public static java.lang.String[] <B>split</B>(java.lang.String&nbsp;path,
                                       char&nbsp;sep)</PRE>
<DL>
<DD>Split a String representing a path-like sequence into individual
 parts where indicated by the given separator char.
 Multiple adjacent occurances of the separator in the path are treated as
 a single separator.  They do not yield multiple empty nor null parts.
 Leading separators are treated the same as no leading separators,
 so if your semantics require a distinction, you must determine it for
 yourself, e.g. with String.startsWith().
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isAcceptablePart(java.lang.String)"><!-- --></A><H3>
isAcceptablePart</H3>
<PRE>
protected boolean <B>isAcceptablePart</B>(java.lang.String&nbsp;part)</PRE>
<DL>
<DD>Return true if the given String is acceptable to be added as a part.
 This implementation rejects null's and zero-length parts.
 If you override in sub-classes, you must never accept null, as it makes the 
 result of some methods ambiguous or prone to throwing NullPointerException's.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toEscapedForm(java.lang.String)"><!-- --></A><H3>
toEscapedForm</H3>
<PRE>
public java.lang.String <B>toEscapedForm</B>(java.lang.String&nbsp;toTransform)</PRE>
<DL>
<DD>Transform the given String to an escaped form, whatever that may be.
 Must accept null or zero-length Strings, and return them without error or exception.
 Though principally for internal use, this method is public because the transformation
 to and from escaped form is a useful feature of each instance.
<p>
 This method must always perform a transformation, regardless of any internal
 state indicating whether escapes are in use or not.
 That is, this is strictly a transforming method, not a state-sensitive accessor method.
<p>
 This implementation performs no transformation, always returning its argument.
 Sub-classes may override to transform in ways they see fit.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toLiteralForm(java.lang.String)"><!-- --></A><H3>
toLiteralForm</H3>
<PRE>
public java.lang.String <B>toLiteralForm</B>(java.lang.String&nbsp;toTransform)</PRE>
<DL>
<DD>Transform the given String to a literal (unescaped) form, whatever that may be.
 Must accept null or zero-length Strings, and return them without error or exception.
 Though principally for internal use, this method is public because the transformation
 to and from escaped form is a useful feature of each instance.
<p>
 This method must always perform a transformation, regardless of any internal
 state indicating whether escapes are in use or not.
 That is, this is strictly a transforming method, not a state-sensitive accessor method.
<p>
 This implementation performs no transformation, always returning its argument.
 Sub-classes may override to transform in ways they see fit.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="buildPath(char, boolean, boolean)"><!-- --></A><H3>
buildPath</H3>
<PRE>
public java.lang.StringBuffer <B>buildPath</B>(char&nbsp;between,
                                        boolean&nbsp;initially,
                                        boolean&nbsp;useEscapes)</PRE>
<DL>
<DD>Create a StringBuffer holding all the parts, placing the given char between the parts,
 and also placing it initially if the flag is true.  The StringBuffer contains the escaped or 
 unescaped (literal) parts according to the given useEscapes flag.
 That flag is passed to getPart(int,boolean) to retrieve each part assembled.
 When this instance has no parts, the returned String is zero-length when initially is false,
 or the returned String contains a single between char when initially is true.
 This method is a building-block commonly used to define overrides of getPath()
 or more specialized but similar methods.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="ensureCapacity(int)"><!-- --></A><H3>
ensureCapacity</H3>
<PRE>
public void <B>ensureCapacity</B>(int&nbsp;partCount)</PRE>
<DL>
<DD>Ensure the given capacity, growing the array as needed while preserving current contents.
 This has no effect on part-count, only on available array capacity.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="partCount()"><!-- --></A><H3>
partCount</H3>
<PRE>
public int <B>partCount</B>()</PRE>
<DL>
<DD>Return the current part-count.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clear()"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>()</PRE>
<DL>
<DD>Clear all the parts, but don't reduce the current capacity.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="set(java.lang.String[])"><!-- --></A><H3>
set</H3>
<PRE>
public void <B>set</B>(java.lang.String[]&nbsp;toCopy)</PRE>
<DL>
<DD>Clear all the parts, then append the given Strings by calling appendAll( String[] ).
 If toCopy is null, this is cleared and nothing is appended.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../glguerin/io/Path.html#appendAll(java.lang.String[])"><CODE>appendAll(java.lang.String[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setFrom(java.lang.String, char)"><!-- --></A><H3>
setFrom</H3>
<PRE>
public void <B>setFrom</B>(java.lang.String&nbsp;path,
                    char&nbsp;sep)</PRE>
<DL>
<DD>Split the given String into parts where indicated by the given separator char,
 assigning them as the parts of this object.
 If path is null, this object is just cleared.
 Multiple adjacent occurances of the separator in the path are treated as
 a single separator.  They do not yield multiple empty nor null components.
 Leading separators are treated the same as no leading separators,
 so if your semantics require a distinction, you must determine this for
 yourself, e.g. with String.startsWith().
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reverse()"><!-- --></A><H3>
reverse</H3>
<PRE>
public void <B>reverse</B>()</PRE>
<DL>
<DD>Reverse the order of the parts.
 Does not reverse the individual part-Strings, only the order.
 Does not invoke any other Path methods.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="append(java.lang.String)"><!-- --></A><H3>
append</H3>
<PRE>
public void <B>append</B>(java.lang.String&nbsp;toAppend)</PRE>
<DL>
<DD>Append the given part String, growing the internal storage as needed.  
 If toAppend is unacceptable, it's quietly ignored.
<p>
 Acceptance is determined by the protected method isAcceptablePart().
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../glguerin/io/Path.html#isAcceptablePart(java.lang.String)"><CODE>isAcceptablePart(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="appendAll(java.lang.String[])"><!-- --></A><H3>
appendAll</H3>
<PRE>
public void <B>appendAll</B>(java.lang.String[]&nbsp;toAppend)</PRE>
<DL>
<DD>Append all the items in toAppend using the append(String) method.
 If toAppend is null or zero-length, nothing is appended.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../glguerin/io/Path.html#append(java.lang.String)"><CODE>append(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="trim()"><!-- --></A><H3>
trim</H3>
<PRE>
public java.lang.String <B>trim</B>()</PRE>
<DL>
<DD>Trim the most recently added part, and return it.
 Returns null if there are no parts left.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="swap(java.lang.String)"><!-- --></A><H3>
swap</H3>
<PRE>
public java.lang.String <B>swap</B>(java.lang.String&nbsp;toSwap)</PRE>
<DL>
<DD>Swap the given String with the last part, using trim() and append().  
 If toSwap is null, the result is equivalent to trim(), since you can't have null parts.
 If there are no parts to begin with, the result is equivalent to append(),
 and null is returned.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="last()"><!-- --></A><H3>
last</H3>
<PRE>
public java.lang.String <B>last</B>()</PRE>
<DL>
<DD>Return the last part, or null if no parts.
 This is operationally equivalent to 
 <b>part( partCount() - 1 )</b> but is more concise and efficient.
 As with part(int), escaping is not applied.
 This implementation calls no other methods.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="part(int)"><!-- --></A><H3>
part</H3>
<PRE>
public java.lang.String <B>part</B>(int&nbsp;index)</PRE>
<DL>
<DD>Return the indexed part without escaping it, or null if out of range.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPart(int, boolean)"><!-- --></A><H3>
getPart</H3>
<PRE>
public java.lang.String <B>getPart</B>(int&nbsp;index,
                                boolean&nbsp;useEscapes)</PRE>
<DL>
<DD>Return the indexed part with the given escaping applied, or null if out of range.
 Invokes the methods part(int) and toEscapedForm(String).
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getParts(boolean)"><!-- --></A><H3>
getParts</H3>
<PRE>
public java.lang.String[] <B>getParts</B>(boolean&nbsp;useEscapes)</PRE>
<DL>
<DD>Return a new array holding all the parts, with escapes applied according
 to the given flag.  
 Invokes the methods part(int) and toEscapedForm(String)
 to fill the array, but not getPart(int).
 If there are no parts, the returned array is zero-length, but never null.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPath()"><!-- --></A><H3>
getPath</H3>
<PRE>
public java.lang.String <B>getPath</B>()</PRE>
<DL>
<DD>Return a String consisting of the Path parts separated by an internally determined
 separator.
 This implementation uses a comma separator, without a leading separator, and without escapes.
 Sub-classes should override this method and setPath() to act as desired.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../glguerin/io/Path.html#setPath(java.lang.String)"><CODE>setPath(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setPath(java.lang.String)"><!-- --></A><H3>
setPath</H3>
<PRE>
public void <B>setPath</B>(java.lang.String&nbsp;path)</PRE>
<DL>
<DD>Set the parts from the given String, separated by some internally determined
 separator.
 This implementation uses a comma separator, just like getPath() does.
 Sub-classes should override this method and getPath() to act as desired.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../glguerin/io/Path.html#getPath()"><CODE>getPath()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Override Object.toString(), returning the getPath() value.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A><H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>Override Object.hashCode(), returning the partCount().
 I'm sure one could devise a hash-code that gave fewer collisions,
 but that's probably more appropriate for sub-classes.
 Just ensure that two Path's for which equals(Object) yields true
 return identical hash-codes.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>hashCode</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A><H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD>Override Object.equals(Object), returning true if every unescaped
 part in this instance String.equals() every unescaped part in other.
 Sub-classes can override, e.g. performing String.equalsIgnoreCase() instead
 of String.equals().
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>equals</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../glguerin/io/FilePathname.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Path.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
