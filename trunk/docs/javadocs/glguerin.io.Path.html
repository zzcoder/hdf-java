<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd>
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Tue Jan 22 13:04:11 CST 2002-->
<TITLE>
Class glguerin.io.Path
</TITLE>
</HEAD>
<BODY>
<A NAME="_top_"><!-- --></A>
<PRE>
<A HREF="packages.html">All Packages</A>  <A HREF="tree.html">Class Hierarchy</A>  <A HREF="package-glguerin.io.html">This Package</A>  <A HREF="glguerin.io.FilePathname.html">Previous</A>  Next  <A HREF="index-1.html">Index</A></PRE>
<HR>
<H2>
Class glguerin.io.Path
</H2>
<PRE>
java.lang.Object
    |
    +----glguerin.io.Path
</PRE>
<HR>
<DL>
<DT>public class <B>Path</B><DT>extends java.lang.Object</DL>
A Path is an ordered sequence of String parts, often representing a progressively
 more qualified name-sequence (such as a file-name), or an ordered series of elements
 (such as a search-path).
 The parts are randomly retrievable by index, 
 or retrievable as a String array,
 or can be assembled into a single String with embedded separators, 
 Parts are not randomly accessible for alteration.
 A Path's parts can only be altered altered at the tail end of the sequence, i.e. by appending
 or trimming the last part.  Eliminating random-access alteration, such as in java.util.Vector, 
 makes altering a Path substantially more efficient.
<p>
 The order/sequence of the parts can be reversed by reverse().
 This is useful when you need to build a Path in reverse order from the eventual
 ordered sequence you want.  You can also use it to prepend a part, invoking
 the methods as: reverse(), append(newPart), reverse().
 I'm sure you can think of other uses.
<p>
 The class Path will most likely used as a base-class for more specialized classes,
 such as one to specifically represent a file-name path (FilePathname).  One should also note
 that a Path sub-class can easily represent other ordered sequences, such as a class-path or
 a DNS-name.
<p>
 No methods in this class are synchronized, even when a thread-safety issue
 is known to exist.
 If you need thread-safety you must provide it yourself.  
 The most common uses of this class do not involve shared access
 by multiple threads, so synchronizing seemed like a time-wasting overkill.
 If you disagree, you have the source...
<P>
<DL>
<DT><B>Author:</B> <DD>Gregory Guerin
</DD>
<DT><B>See Also:</B><DD><A HREF="glguerin.io.FilePathname.html">FilePathname</A></DL>
<HR>

<P>
<A NAME="index"><!-- --></A><H2>
<IMG SRC="images/constructor-index.gif" WIDTH="275" HEIGHT="38" ALT="Constructor Index">
</H2>
<DL>
<DT><IMG SRC="images/yellow-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#Path()">Path</A>()
<DD>Create with no parts.
<DT><IMG SRC="images/yellow-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#Path(int)">Path</A>(int)
<DD>Create with initial space for given part-count, but no actual parts.
<DT><IMG SRC="images/yellow-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#Path(java.lang.String[])">Path</A>(String[])
<DD>Create with initial parts.
</DL>
<H2>
<IMG SRC="images/method-index.gif" WIDTH="207" HEIGHT="38" ALT="Method Index">
</H2>
<DL>
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#append(java.lang.String)">append</A>(String)
<DD>Append the given part String, growing the internal storage as needed.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#appendAll(java.lang.String[])">appendAll</A>(String[])
<DD>Append all the items in toAppend using the append(String) method.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#buildPath(char, boolean, boolean)">buildPath</A>(char, boolean, boolean)
<DD>Create a StringBuffer holding all the parts, placing the given char between the parts,
 and also placing it initially if the flag is true.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#clear()">clear</A>()
<DD>Clear all the parts, but don't reduce the current capacity.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#ensureCapacity(int)">ensureCapacity</A>(int)
<DD>Ensure the given capacity, growing the array as needed while preserving current contents.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#equals(java.lang.Object)">equals</A>(Object)
<DD>Override Object.equals(Object), returning true if every unescaped
 part in this instance String.equals() every unescaped part in other.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#getPart(int, boolean)">getPart</A>(int, boolean)
<DD>Return the indexed part with the given escaping applied, or null if out of range.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#getParts(boolean)">getParts</A>(boolean)
<DD>Return a new array holding all the parts, with escapes applied according
 to the given flag.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#getPath()">getPath</A>()
<DD>Return a String consisting of the Path parts separated by an internally determined
 separator.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#hashCode()">hashCode</A>()
<DD>Override Object.hashCode(), returning the partCount().
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#isAcceptablePart(java.lang.String)">isAcceptablePart</A>(String)
<DD>Return true if the given String is acceptable to be added as a part.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#last()">last</A>()
<DD>Return the last part, or null if no parts.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#part(int)">part</A>(int)
<DD>Return the indexed part without escaping it, or null if out of range.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#partCount()">partCount</A>()
<DD>Return the current part-count.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#reverse()">reverse</A>()
<DD>Reverse the order of the parts.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#set(java.lang.String[])">set</A>(String[])
<DD>Clear all the parts, then append the given Strings by calling appendAll( String[] ).
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#setFrom(java.lang.String, char)">setFrom</A>(String, char)
<DD>Split the given String into parts where indicated by the given separator char,
 assigning them as the parts of this object.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#setPath(java.lang.String)">setPath</A>(String)
<DD>Set the parts from the given String, separated by some internally determined
 separator.
<DT><IMG SRC="images/green-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#split(java.lang.String, char)">split</A>(String, char)
<DD>Split a String representing a path-like sequence into individual
 parts where indicated by the given separator char.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#swap(java.lang.String)">swap</A>(String)
<DD>Swap the given String with the last part, using trim() and append().
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#toEscapedForm(java.lang.String)">toEscapedForm</A>(String)
<DD>Transform the given String to an escaped form, whatever that may be.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#toLiteralForm(java.lang.String)">toLiteralForm</A>(String)
<DD>Transform the given String to a literal (unescaped) form, whatever that may be.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#toString()">toString</A>()
<DD>Override Object.toString(), returning the getPath() value.
<DT><IMG SRC="images/red-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#trim()">trim</A>()
<DD>Trim the most recently added part, and return it.
</DL>
<A NAME="constructors"><!-- --></A><H2>
<IMG SRC="images/constructors.gif" WIDTH="231" HEIGHT="38" ALT="Constructor Detail">
</H2>
<A NAME="Path()"><IMG SRC="images/yellow-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><B>Path</B><PRE>
public <B>Path</B>()</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create with no parts.</DL>
<A NAME="Path(int)"><IMG SRC="images/yellow-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><B>Path</B><PRE>
public <B>Path</B>(int partCount)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create with initial space for given part-count, but no actual parts.</DL>
<A NAME="Path(java.lang.String[])"><IMG SRC="images/yellow-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><B>Path</B><PRE>
public <B>Path</B>(java.lang.String parts[])</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create with initial parts.</DL>
<A NAME="methods"><!-- --></A><H2>
<IMG SRC="images/methods.gif" WIDTH="151" HEIGHT="38" ALT="Method Detail">
</H2>
<A NAME="split(java.lang.String, char)"><IMG SRC="images/green-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="split"><B>split</B></A><PRE>
public static java.lang.String[] <B>split</B>(java.lang.String path,
                             char sep)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Split a String representing a path-like sequence into individual
 parts where indicated by the given separator char.
 Multiple adjacent occurances of the separator in the path are treated as
 a single separator.  They do not yield multiple empty nor null parts.
 Leading separators are treated the same as no leading separators,
 so if your semantics require a distinction, you must determine it for
 yourself, e.g. with String.startsWith().</DL>
<A NAME="isAcceptablePart(java.lang.String)"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="isAcceptablePart"><B>isAcceptablePart</B></A><PRE>
protected boolean <B>isAcceptablePart</B>(java.lang.String part)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return true if the given String is acceptable to be added as a part.
 This implementation rejects null's and zero-length parts.
 If you override in sub-classes, you must never accept null, as it makes the 
 result of some methods ambiguous or prone to throwing NullPointerException's.</DL>
<A NAME="toEscapedForm(java.lang.String)"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="toEscapedForm"><B>toEscapedForm</B></A><PRE>
public java.lang.String <B>toEscapedForm</B>(java.lang.String toTransform)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transform the given String to an escaped form, whatever that may be.
 Must accept null or zero-length Strings, and return them without error or exception.
 Though principally for internal use, this method is public because the transformation
 to and from escaped form is a useful feature of each instance.
<p>
 This method must always perform a transformation, regardless of any internal
 state indicating whether escapes are in use or not.
 That is, this is strictly a transforming method, not a state-sensitive accessor method.
<p>
 This implementation performs no transformation, always returning its argument.
 Sub-classes may override to transform in ways they see fit.</DL>
<A NAME="toLiteralForm(java.lang.String)"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="toLiteralForm"><B>toLiteralForm</B></A><PRE>
public java.lang.String <B>toLiteralForm</B>(java.lang.String toTransform)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transform the given String to a literal (unescaped) form, whatever that may be.
 Must accept null or zero-length Strings, and return them without error or exception.
 Though principally for internal use, this method is public because the transformation
 to and from escaped form is a useful feature of each instance.
<p>
 This method must always perform a transformation, regardless of any internal
 state indicating whether escapes are in use or not.
 That is, this is strictly a transforming method, not a state-sensitive accessor method.
<p>
 This implementation performs no transformation, always returning its argument.
 Sub-classes may override to transform in ways they see fit.</DL>
<A NAME="buildPath(char, boolean, boolean)"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="buildPath"><B>buildPath</B></A><PRE>
public java.lang.StringBuffer <B>buildPath</B>(char between,
                              boolean initially,
                              boolean useEscapes)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a StringBuffer holding all the parts, placing the given char between the parts,
 and also placing it initially if the flag is true.  The StringBuffer contains the escaped or 
 unescaped (literal) parts according to the given useEscapes flag.
 That flag is passed to getPart(int,boolean) to retrieve each part assembled.
 When this instance has no parts, the returned String is zero-length when initially is false,
 or the returned String contains a single between char when initially is true.
 This method is a building-block commonly used to define overrides of getPath()
 or more specialized but similar methods.</DL>
<A NAME="ensureCapacity(int)"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="ensureCapacity"><B>ensureCapacity</B></A><PRE>
public void <B>ensureCapacity</B>(int partCount)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ensure the given capacity, growing the array as needed while preserving current contents.
 This has no effect on part-count, only on available array capacity.</DL>
<A NAME="partCount()"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="partCount"><B>partCount</B></A><PRE>
public int <B>partCount</B>()</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the current part-count.</DL>
<A NAME="clear()"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="clear"><B>clear</B></A><PRE>
public void <B>clear</B>()</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clear all the parts, but don't reduce the current capacity.</DL>
<A NAME="set(java.lang.String[])"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="set"><B>set</B></A><PRE>
public void <B>set</B>(java.lang.String toCopy[])</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clear all the parts, then append the given Strings by calling appendAll( String[] ).
 If toCopy is null, this is cleared and nothing is appended.<DD><DL>
<DT><B>See Also:</B><DD><A HREF="#appendAll(java.lang.String[])">appendAll</A></DL>
</DD>
</DL>
<A NAME="setFrom(java.lang.String, char)"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="setFrom"><B>setFrom</B></A><PRE>
public void <B>setFrom</B>(java.lang.String path,
                    char sep)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Split the given String into parts where indicated by the given separator char,
 assigning them as the parts of this object.
 If path is null, this object is just cleared.
 Multiple adjacent occurances of the separator in the path are treated as
 a single separator.  They do not yield multiple empty nor null components.
 Leading separators are treated the same as no leading separators,
 so if your semantics require a distinction, you must determine this for
 yourself, e.g. with String.startsWith().</DL>
<A NAME="reverse()"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="reverse"><B>reverse</B></A><PRE>
public void <B>reverse</B>()</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reverse the order of the parts.
 Does not reverse the individual part-Strings, only the order.
 Does not invoke any other Path methods.</DL>
<A NAME="append(java.lang.String)"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="append"><B>append</B></A><PRE>
public void <B>append</B>(java.lang.String toAppend)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Append the given part String, growing the internal storage as needed.  
 If toAppend is unacceptable, it's quietly ignored.
<p>
 Acceptance is determined by the protected method isAcceptablePart().<DD><DL>
<DT><B>See Also:</B><DD><A HREF="#isAcceptablePart(java.lang.String)">isAcceptablePart</A></DL>
</DD>
</DL>
<A NAME="appendAll(java.lang.String[])"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="appendAll"><B>appendAll</B></A><PRE>
public void <B>appendAll</B>(java.lang.String toAppend[])</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Append all the items in toAppend using the append(String) method.
 If toAppend is null or zero-length, nothing is appended.<DD><DL>
<DT><B>See Also:</B><DD><A HREF="#append(java.lang.String)">append</A></DL>
</DD>
</DL>
<A NAME="trim()"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="trim"><B>trim</B></A><PRE>
public java.lang.String <B>trim</B>()</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trim the most recently added part, and return it.
 Returns null if there are no parts left.</DL>
<A NAME="swap(java.lang.String)"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="swap"><B>swap</B></A><PRE>
public java.lang.String <B>swap</B>(java.lang.String toSwap)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swap the given String with the last part, using trim() and append().  
 If toSwap is null, the result is equivalent to trim(), since you can't have null parts.
 If there are no parts to begin with, the result is equivalent to append(),
 and null is returned.</DL>
<A NAME="last()"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="last"><B>last</B></A><PRE>
public java.lang.String <B>last</B>()</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the last part, or null if no parts.
 This is operationally equivalent to 
 <b>part( partCount() - 1 )</b> but is more concise and efficient.
 As with part(int), escaping is not applied.
 This implementation calls no other methods.</DL>
<A NAME="part(int)"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="part"><B>part</B></A><PRE>
public java.lang.String <B>part</B>(int index)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the indexed part without escaping it, or null if out of range.</DL>
<A NAME="getPart(int, boolean)"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="getPart"><B>getPart</B></A><PRE>
public java.lang.String <B>getPart</B>(int index,
                      boolean useEscapes)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the indexed part with the given escaping applied, or null if out of range.
 Invokes the methods part(int) and toEscapedForm(String).</DL>
<A NAME="getParts(boolean)"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="getParts"><B>getParts</B></A><PRE>
public java.lang.String[] <B>getParts</B>(boolean useEscapes)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a new array holding all the parts, with escapes applied according
 to the given flag.  
 Invokes the methods part(int) and toEscapedForm(String)
 to fill the array, but not getPart(int).
 If there are no parts, the returned array is zero-length, but never null.</DL>
<A NAME="getPath()"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="getPath"><B>getPath</B></A><PRE>
public java.lang.String <B>getPath</B>()</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a String consisting of the Path parts separated by an internally determined
 separator.
 This implementation uses a comma separator, without a leading separator, and without escapes.
 Sub-classes should override this method and setPath() to act as desired.<DD><DL>
<DT><B>See Also:</B><DD><A HREF="#setPath(java.lang.String)">setPath</A></DL>
</DD>
</DL>
<A NAME="setPath(java.lang.String)"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="setPath"><B>setPath</B></A><PRE>
public void <B>setPath</B>(java.lang.String path)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the parts from the given String, separated by some internally determined
 separator.
 This implementation uses a comma separator, just like getPath() does.
 Sub-classes should override this method and getPath() to act as desired.<DD><DL>
<DT><B>See Also:</B><DD><A HREF="#getPath()">getPath</A></DL>
</DD>
</DL>
<A NAME="toString()"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="toString"><B>toString</B></A><PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Override Object.toString(), returning the getPath() value.<DD><DL>
<DT><B>Overrides:</B><DD><A HREF="java.lang.Object.html#toString()">toString</A> in class java.lang.Object</DL>
</DD>
</DL>
<A NAME="hashCode()"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="hashCode"><B>hashCode</B></A><PRE>
public int <B>hashCode</B>()</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Override Object.hashCode(), returning the partCount().
 I'm sure one could devise a hash-code that gave fewer collisions,
 but that's probably more appropriate for sub-classes.
 Just ensure that two Path's for which equals(Object) yields true
 return identical hash-codes.<DD><DL>
<DT><B>Overrides:</B><DD><A HREF="java.lang.Object.html#hashCode()">hashCode</A> in class java.lang.Object</DL>
</DD>
</DL>
<A NAME="equals(java.lang.Object)"><IMG SRC="images/red-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="equals"><B>equals</B></A><PRE>
public boolean <B>equals</B>(java.lang.Object other)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Override Object.equals(Object), returning true if every unescaped
 part in this instance String.equals() every unescaped part in other.
 Sub-classes can override, e.g. performing String.equalsIgnoreCase() instead
 of String.equals().<DD><DL>
<DT><B>Overrides:</B><DD><A HREF="java.lang.Object.html#equals(java.lang.Object)">equals</A> in class java.lang.Object</DL>
</DD>
</DL>
<HR>
<PRE>
<A HREF="packages.html">All Packages</A>  <A HREF="tree.html">Class Hierarchy</A>  <A HREF="package-glguerin.io.html">This Package</A>  <A HREF="glguerin.io.FilePathname.html">Previous</A>  Next  <A HREF="index-1.html">Index</A></PRE>

</BODY>
</HTML>
