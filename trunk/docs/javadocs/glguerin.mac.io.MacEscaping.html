<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd>
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Tue Jan 29 11:24:16 CST 2002-->
<TITLE>
Class glguerin.mac.io.MacEscaping
</TITLE>
</HEAD>
<BODY>
<A NAME="_top_"><!-- --></A>
<PRE>
<A HREF="packages.html">All Packages</A>  <A HREF="tree.html">Class Hierarchy</A>  <A HREF="package-glguerin.mac.io.html">This Package</A>  Previous  <A HREF="glguerin.mac.io.MacFilePathname.html">Next</A>  <A HREF="index-1.html">Index</A></PRE>
<HR>
<H2>
Class glguerin.mac.io.MacEscaping
</H2>
<PRE>
java.lang.Object
    |
    +----glguerin.mac.io.MacEscaping
</PRE>
<HR>
<DL>
<DT>public class <B>MacEscaping</B><DT>extends java.lang.Object</DL>
MacEscaping contains static utility methods for working with escaped
 and unescaped Mac OS file-names.
 It currently provides translation between the escaped (i.e. Java-friendly)
 and unescaped (i.e. raw) forms of names.  It does not translate from
 the Java/MRJ form where "/" is a separator, to the native-Mac form
 where ":" is a separator (and different semantics also exist) -- use a MacFilePathname for that.
 Escaping is used under MRJ because the Mac OS allows /'s in its file-names,
 and at the same time uses "/" as the File.separator to represent path-names.
 Indeed, Mac OS allows any character in a file-name except the native ":" separator.
<p>
 The above situation with "/" arises out of Java's rather limited and Unix-centered view 
 towards file-systems.  
 Though java.io.File is intended to hide these, it doesn't entirely succeed.
 At the very least, the programmers using File were very Unix-centric in their use of File, 
 which leads to the same result -- things that should be abstract and hidden aren't:
<ol>
   <li>The semantics of relative vs. absolute paths is Unix-centric, and
     exactly opposite to the Mac OS's native semantics.  That is, under Unix an absolute
     path starts with File.separator, but under Mac OS that syntax means a relative path.
   <li>The meaning of repeated adjacent File.separator's is presumed to follow
     the Unix-centered approach, i.e. repeats are ignored.  This is not true of Mac OS.
   <li>Named references to "this directory" and "parent directory" are presumed
     to be "." and "..".  This is not true of Mac OS, where the native separator ":"
     is used for this purpose.
   <li>File-system names are presumed to be legal if they start with ".".
     Mac OS used to forbid this, and many existing programs are still unable to
     handle this correctly.  Since Mac OS 7, it's not illegal, though this has not fixed
     the programs (or programmers) who still do things poorly.  Not an issue for new
     code, until you throw an old broken program into the work-flow.  Oops.
</ol>
 All these eminently foreseeable defects in File made it a real, um, <i>challenge </i>to 
 implement Java under Mac OS.  Even if File had been defined to use URL semantics to
 represent file-names, it would have been better.  Alas, now we're stuck with it --
 a stone-axe in a laser-scalpel world.
<p>
<i>[And this doesn't even cover the case where Mac OS allows
 multiple volumes of the same name to be mounted at the same time, without ambiguity.
 With path-names alone, Java programs on the Mac are still susceptible to this ambiguity.
 If you can't think of why or how that might happen, imagine a CD-ROM back-up of a volume,
 or two CD-ROM's mounted at the same time, containing different revisions of a
 commercial product.  You want to do a differential compare, yet you can't because
 the names alone are ambiguous.  If you actually need to disambiguate something like this, 
 JConfig may help you:
<br>&nbsp;&nbsp;
 <b>http://www.tolstoy.com/samizdat/jconfig.html</b>
 ]</i>
<p>
 Thus, to avoid difficulties in working with Java programs
 (and programmers) that already operated under Unix semantics when
 working with Files, MRJ's creators chose to just provide Unix-like semantics as much as possible.
 This includes the use of "/" as separator, the use of "." and ".." as directory-names, 
 and various other aspects.
 One difficulty with this scheme is that a literal "/" is not uncommon in native Mac OS file-names.
 So MRJ uses an escaping scheme similar to the HTTP URL scheme, i.e. the character '%'
 introduces a two-hex-digit escape encoding the character-value.
 In MRJ 2.0 and earlier, some ASCII characters were escaped in addition to "/" and "%" themselves.
 Also, MacRoman characters were escaped as their MacRoman byte-values rather than
 converted to UniCode chars, 
 e.g. %83 represents <b>capital-E acute</b>, not a UniCode control-char.
 Under MRJ 2.1, only "/" and "%" are escaped, and MacRoman characters are
 translated to UniCode chars.
<p>
 Note that these escapes are all Java-only constructs, and appear only to Java programs running
 under MRJ.  Calls to native Mac OS code still require the Mac-format path-name without escapes.
 Users also expect to see a file named "4/99 Budget" as exactly that, not "4%2f99 Budget",
 so hanlding escapes is an important user-visible feature, too.
<P>
<DL>
<DT><B>Author:</B> <DD>Gregory Guerin
</DD>
<DT><B>See Also:</B><DD>MacCatalogInfo, <A HREF="glguerin.mac.io.MacFilePathname.html">MacFilePathname</A></DL>
<HR>

<P>
<A NAME="index"><!-- --></A><H2>
<IMG SRC="images/variable-index.gif" WIDTH="207" HEIGHT="38" ALT="Variable Index">
</H2>
<DL>
<DT><IMG SRC="images/blue-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#ESCAPE">ESCAPE</A><DD>The MRJ escaping character, '%'.
<DT><IMG SRC="images/blue-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#MRJ_SEP">MRJ_SEP</A><DD>MRJ's file-separator as Java-code sees it, '/'.
<DT><IMG SRC="images/blue-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#NATIVE_SEP">NATIVE_SEP</A><DD>Mac OS's native file-separator, ':'.
<DT><IMG SRC="images/blue-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#NATIVE_SUB">NATIVE_SUB</A><DD>What you should substitute for literal NATIVE_SEP characters
 that might appear in file-names you deal with, '-'.
</DL>
<H2>
<IMG SRC="images/constructor-index.gif" WIDTH="275" HEIGHT="38" ALT="Constructor Index">
</H2>
<DL>
<DT><IMG SRC="images/yellow-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#MacEscaping()">MacEscaping</A>()
<DD>&nbsp;
</DL>
<H2>
<IMG SRC="images/method-index.gif" WIDTH="207" HEIGHT="38" ALT="Method Index">
</H2>
<DL>
<DT><IMG SRC="images/green-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#containsMacEscapees(java.lang.String)">containsMacEscapees</A>(String)
<DD>Determine whether the given String contains any characters that will need
 escaping or conversion in order to be used as a Mac file-name part.
<DT><IMG SRC="images/green-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#fromMacRoman(int)">fromMacRoman</A>(int)
<DD>Translate the low 8-bits of the value into a UniCode char using the MacRoman encoding.
<DT><IMG SRC="images/green-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#getOSTypeString(int)">getOSTypeString</A>(int)
<DD>Returns a UniCode String of 4 chars length, holding the expression
 of the macOSType as converted from MacRoman-bytes to UniCode.
<DT><IMG SRC="images/green-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#platformUsesEscapes()">platformUsesEscapes</A>()
<DD>Determine whether the current platform uses escape-sequences in filenames
 or not.
<DT><IMG SRC="images/green-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#toEscapedName(java.lang.String)">toEscapedName</A>(String)
<DD>If the given String, a file-name part, contains characters which must
 be escaped on the Mac, return the escaped form, otherwise return the original String.
<DT><IMG SRC="images/green-ball-small.gif" WIDTH="6" HEIGHT="6" ALT=" o ">
<A HREF="#toLiteralName(java.lang.String)">toLiteralName</A>(String)
<DD>Return a String with Mac-escaping removed.
</DL>
<A NAME="variables"><!-- --></A><H2>
<IMG SRC="images/variables.gif" WIDTH="153" HEIGHT="38" ALT="Field Detail">
</H2>
<A NAME="ESCAPE"><IMG SRC="images/blue-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><B>ESCAPE</B><PRE>
public static final char <B>ESCAPE</B></PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MRJ escaping character, '%'.</DL>
<A NAME="MRJ_SEP"><IMG SRC="images/blue-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><B>MRJ_SEP</B><PRE>
public static final char <B>MRJ_SEP</B></PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MRJ's file-separator as Java-code sees it, '/'.</DL>
<A NAME="NATIVE_SEP"><IMG SRC="images/blue-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><B>NATIVE_SEP</B><PRE>
public static final char <B>NATIVE_SEP</B></PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mac OS's native file-separator, ':'. 
 This character has a special meaning under Microsoft's OS'es, too,
 so you may encounter problems if you blindly convert something like
 "C:foo\bar\barf.dat" to what may seem to be a platform-neutral form.</DL>
<A NAME="NATIVE_SUB"><IMG SRC="images/blue-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><B>NATIVE_SUB</B><PRE>
public static final char <B>NATIVE_SUB</B></PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;What you should substitute for literal NATIVE_SEP characters
 that might appear in file-names you deal with, '-'.
 Don't try this on a path-name from a Microsoft OS, though, or
 you'll nuke the "drive-letter" part of the name.</DL>
<A NAME="constructors"><!-- --></A><H2>
<IMG SRC="images/constructors.gif" WIDTH="231" HEIGHT="38" ALT="Constructor Detail">
</H2>
<A NAME="MacEscaping()"><IMG SRC="images/yellow-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><B>MacEscaping</B><PRE>
public <B>MacEscaping</B>()</PRE>
<DL>
</DL>
<A NAME="methods"><!-- --></A><H2>
<IMG SRC="images/methods.gif" WIDTH="151" HEIGHT="38" ALT="Method Detail">
</H2>
<A NAME="fromMacRoman(int)"><IMG SRC="images/green-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="fromMacRoman"><B>fromMacRoman</B></A><PRE>
public static char <B>fromMacRoman</B>(int value)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translate the low 8-bits of the value into a UniCode char using the MacRoman encoding.
 That is, the low 8-bits of value are presumed to be a MacRoman-encoded value,
 so convert it to its UniCode representation.
 Though generally useful when dealing with MacRoman bytes, this method
 is specifically used in toLiteralName() to translate escaped byte-values to chars.<DD><DL>
<DT><B>Returns:</B><DD>The UniCode representation of the low 8-bits of value, interpreted as a MacRoman byte.</DL>
</DD>
</DL>
<A NAME="platformUsesEscapes()"><IMG SRC="images/green-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="platformUsesEscapes"><B>platformUsesEscapes</B></A><PRE>
public static boolean <B>platformUsesEscapes</B>()</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine whether the current platform uses escape-sequences in filenames
 or not.  This method invokes MacPlatform.isMacOS() and assumes the returned 
 boolean is identical to the escape-using characteristic.
 This means that all JVM's running under any version of Mac OS are 
 presumed to use escaping, which may not actually be the case.  
 In particular, I don't know what Mac OS X Server returns when 
 running outside of the Blue Box.  Nor do I know what Mac OS X Consumer will return.<DD><DL>
<DT><B>Returns:</B><DD>True if this platform uses escape-sequences in java.io.File name-parts, false if not.<DT><B>See Also:</B><DD><A HREF="glguerin.util.MacPlatform.html#isMacOS()">isMacOS</A></DL>
</DD>
</DL>
<A NAME="containsMacEscapees(java.lang.String)"><IMG SRC="images/green-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="containsMacEscapees"><B>containsMacEscapees</B></A><PRE>
public static boolean <B>containsMacEscapees</B>(java.lang.String given)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine whether the given String contains any characters that will need
 escaping or conversion in order to be used as a Mac file-name part.
 Returns true if if the given String contains characters which need to be
 escaped on the Mac, false if it contains no such characters.
 If the given String is null, then false is returned without throwing an exception.
<p>
 This method does not identify the Mac's native separator ":" as being an escapee.
 This is intentional.</DL>
<A NAME="toEscapedName(java.lang.String)"><IMG SRC="images/green-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="toEscapedName"><B>toEscapedName</B></A><PRE>
public static java.lang.String <B>toEscapedName</B>(java.lang.String literalName)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the given String, a file-name part, contains characters which must
 be escaped on the Mac, return the escaped form, otherwise return the original String.
 The given literalName <b>IS NOT</b> a full path-name, only a single part thereof.
 Separators appearing in literalName are treated as literal characters, not separators,
 and will be escaped.  This is the whole reason for having escaped names anyway.
<p>
 This method only performs escaping, not encoding from MacRoman or other schemes.
 This method won't translate ':' (NATIVE_SEP) to '-' (NATIVE_SUB), either.
 If you want either of these, you'll have to do them yourself.
<p>
 If the given String is null, then null is returned without throwing an exception.</DL>
<A NAME="toLiteralName(java.lang.String)"><IMG SRC="images/green-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="toLiteralName"><B>toLiteralName</B></A><PRE>
public static java.lang.String <B>toLiteralName</B>(java.lang.String escapedName)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a String with Mac-escaping removed.
 If there are no escape-sequences (no '%' chars) at all,  
 the original String is immediately returned.
 This method only performs unescaping, not encoding.
 If the given String is null, then null is returned without throwing an exception.
<p>
 Escapes in the range %80-%FF will be converted as if they represent MacRoman bytes.
 For example, %83 is converted to UniCode ? (capital-E acute), rather than to
 the direct UniCode representation of ? (a control-char).
 The reason for this intepretation of escapes is that MRJ 2.0 and earlier represent
 file-name characters in the range 0x80-0xFF as escapes, not as UniCode chars.
 Since these escapes often represent a literal MacRoman byte, it would be
 improper to interpret them as UniCode-encoded escapes.
<p>
 If an apparent escape-sequence can't be decoded, it's kept as-is in the literal form.
 For example, "%fr" is not valid, because "fr" is not a hex value.
 The result is that "%fr" is copied verbatim to the result.
 If there aren't 2 chars after a'%', the sequence is also copied verbatim to the result.</DL>
<A NAME="getOSTypeString(int)"><IMG SRC="images/green-ball.gif" WIDTH="12" HEIGHT="12" ALT=" o ">
</A><A NAME="getOSTypeString"><B>getOSTypeString</B></A><PRE>
public static java.lang.String <B>getOSTypeString</B>(int macOSType)</PRE>
<DL>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a UniCode String of 4 chars length, holding the expression
 of the macOSType as converted from MacRoman-bytes to UniCode.</DL>
<HR>
<PRE>
<A HREF="packages.html">All Packages</A>  <A HREF="tree.html">Class Hierarchy</A>  <A HREF="package-glguerin.mac.io.html">This Package</A>  Previous  <A HREF="glguerin.mac.io.MacFilePathname.html">Next</A>  <A HREF="index-1.html">Index</A></PRE>

</BODY>
</HTML>
