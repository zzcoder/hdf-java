<?php
include ("../../../links.php"); 
include ("../../../includes/header.html"); 
?>

<p>
<fieldset><h1>
Design and Implementation</h1></fieldset>
<p>

<p>
<table BORDER=1 CELLSPACING=2 CELLPADDING=4 BGCOLOR="#DBEAF5" align="center" >
<tr>
<td>


<b>Important Note</b>
<p>This documentation has not been updated to reflect changes since 1997.
<P>Most of the information is correct, but please see the release notes
for important changes
<p><i>11/19/99</i></td>
</tr>
</table>

<h3>
Abstract</h3>
Applications access Hierarchical Data Format (HDF) files through the
HDF library code. In the absence of a Java(TM) implementation of the HDF
library (an extremely remote contingency), Java applications that need
to directly access data in HDF files require a Java interface to the native
code HDF library. This document describes the design of the Java interface
for the HDF library.
<h3>
1. Introduction</h3>
The current release of the Hierachical Data Format API (HDF 4) is
not a simple or consistent object model. [<a href="#REF1">1</a>] It consists
of a dozen or so ``Interfaces'', with different models of data and data
access. [<a href="#REF2">2</a>,
<a href="#REF3">3</a>] This reflects the
history of development, as new features have been introduce while older
features have been maintained for compatibility. The size and complexity
of HDF also reflects the diversity ot uses and users. Different communities
and applications use particular parts of the HDF API. In this sense, HDF
represents the ``union'' of several data models.
<p>While the different data models inherent in the HDF API are related
both conceptually and in implementation, there is not really an inheritance
relationship between them, nor a formal object model. Also, there are significant
inconsistencies across the different data models, <i>e.g.</i>, in the operations
supported, arguments required and the types of errors returned.
<p>In recent months, there has developed a desire to be able to use HDF
files from Java(TM) programs. This requires either a Java implementation
of the HDF library (highly unlikely at this time), or a Java interface
to the existing HDF library, analogous to the existing Fortran interface
to HDF. This document describes the first release of the ``official'' Java
interface to HDF.
<p>Because the HDF API is not object oriented, creating Java classes to
access the HDF library is not trivial. It is first necessary to create
an object model for HDF, which might be done in many ways. Further, different
communities or applications will need appropriate object models, <i>e.g.</i>,
for imagery or multi-dimensional grids. It is not always easy to discern
the border between the abstractions HDF should provide and what should
be left to the application program. This document describes a standard
set of Java classes to access HDF files, closely modelling the HDF API.
This HDF Java Interface forms a solid foundation for constructing and--more
importantly--sharing problem specific data models, as part of the HDF distribution
or from other parties.
<h4>
1.1 Previous work</h4><p>
In previous work, we have implemented a Java based browser for HDF files,
called the Java HDF Viewer (JHV). [<a href="#REF4">4</a>] Java applets
generally cannot access files or use native code libraries (such as HDF),
so the JHV is implemented as a Java <i>application</i>, that is, as a free
standing program, not a network loadable <i>applet</i>. The JHV application
links to the standard HDF library, through the Java ``native code'' methods
to read HDF files on local disk. The lastest release of the JHV uses the
HDF Java Interface described here.
<p>The JHV has pioneered the implementation of a Java application that
uses HDF. The JHV implements classes such as a tree to display the HDF
objects in a file, and displays of metadata, annotations, data, and imagery
from the HDF file. The JHV also supports subsetting and subsampling of
data from the HDF file. In the future, the JHV will be able to transparently
access remote HDF files, perhaps using RMI or CORBA.
<p>The initial implementation of the JHV implemented a different Java-to-C
wrapper layer. In the initial implementation, only parts of the HDF API
were included, specifically, routines needed by the JHV to inquire about
metadata and to read data. No write functions were implemented, and many
miscellaneous access functions were omitted because they were not needed.
<h4>
1.2 The Java Development Kit (JDK)</h4><p>
The first implementation of the JHV was based on the JDK 1.0.2. [<a href="#REF5">5</a>]
This early release of the Java environment did not support Java-to-C interfaces
very well. The interfacing mechanism was incomplete, poorly documented,
and (most critically) not standard across platforms. Fortunately, many
of the shortcomings of JDK 1.0.2 were addressed by major improvements in
JDK 1.1. [<a href="#REF6">6</a>]
<p>The JDK 1.1 provides the <i>Java Native Interface</i> [<a href="#REF7">7</a>],
which is standardized for <b><i>all</i></b> platforms. The JNI provides
an orthogonal set of C functions to access and manipulate Java classes
and objects. For example, it is possible to ``pin'' Java strings and one
dimensional arrays in memory for use by C code. Thus, the wrapper layer
can move data between the objects of the Java application and the variables
of the HDF I/O library.
<p>A second important addition to the JDK is the addition of the <i>Java
Core Reflection</i> package. [<a href="#REF8">8</a>] This standard set
of Java classes provides the ability to completely discover the type and
methods of Java objects and classes. Intended to support componentware
(such as Java Beans(TM) [<a href="#REF9">9</a>]), this package proved crucial
to implementing self-describing I/O, such as HDF has provided for many
years.
<p>Of particular importance to this effort was the the <b>Array</b> class,
which allows the discovery of the shape, size, and type of arbitrary Java
array objects, and also supports the creation and manipulation of Java
array objects. This package makes it possible to store and retrieve multi-dimensional
Java array objects using HDF.
<h3>
2. The Object Model</h3><p>
As noted, there are potentially many ways to model access to the data object
of HDF. [<a href="#REF10">10</a>,
<a href="#REF11">11</a>] The model described
here chooses to model <i>the HDF library itself</i>. Thus, the central
object in this model are the ``HDF'' object, which has 300 some native
methods, corresponding to all the operations provided by the HDF native
code library. The purpose of this HDF library object is to provide the
foundation for any other object model which wishes to use data in HDF files.
It is likely that most Java applications will not directly use the HDF
object; rather will use more abstract object models which themselves use
HDF to manage and access storage. This is analogous to the role of HDF-EOS:
programs create and manipulate HDF-EOS data objects, not the HDF representations
underlying them. [<a href="#REF12">12</a>]
<h4>
2.1 The principle objects</h4><p>
[...need O diagram here]
<p>The objects of the model are:<p>
<ul class="ul">
<li class="li2">
<b>HDF</b> -- The HDF library, with a native method for each HDF entry
point. This is a very simple object, it provides almost one-for-one methods
for the operations and constants of the HDF API. As such, this object has
a very large number of native methods, and practally nothing else.</li>
<p>
<li class="li2">
<b>HDFArray</b> -- Support for converting between arbitrary shaped java
arrays and native code one dimensional arrays of bytes, and vice versa.
This supports the <b>VOIDP</b> data type, which is crucial to HDF's ability
to store and retrieve arbitrary data types. The <b>HDFArray</b> class defines
two important methods:</li>
<p>
<ul class="ul">
<li class="li2">
<i>byteify()</i> -- given a multi-dimensional Java Array object, the equivalent
C array is constructed as a one dimensional array of bytes.</li>
<p>
<li class="li2">
<i>arrayify()</i> -- given a multi-dimensional array from C, construct
the appropriate Java Array object.</li>
</ul>
<p>
<li class="li2">
<b>HDFCompInfo</b> -- support for the HDF compression ``comp_info'' union.
Different compression schemes require specific auxillary parameters, which
are modelled by sub-classes of <b>HDFCompInfo</b>. An example subclass
is:</li>
<p>
<ul class="ul">
<li class="li2">
<b>HDFJPEGCompInfo</b> -- The parameters for JPEG compression: ``quality''
and ``force_baseline''. [<a href="#REF13">13</a>,
<a href="#REF14">14</a>]</li>
</ul>
Other compression (such as Run Length Encoding (RLE)) can be added by creating
another sub-class of HDFCompInfo.<p>
<li class="li2">
<b>HDFCompModel</b> -- support for the HDF compression ``comp_model'' union.</li>
<p>
<li class="li2">
<b>HDFChunkInfo</b> -- support for the HDF chunking ``chunk_info'' union.</li>
<p>
<li class="li2">
<b>HDFException</b> -- error conditions from HDF operations. There are
two main sub-classes, which may in turn be specialized to reflect specific
error conditions.</li>
<p>
<ul class="ul">
<li class="li2">
<b>HDFLibraryException </b>-- represents errors reported by the HDF library
code. The Java wrapper code must detect the error from the native library
and raise an appropriate exception. Subclasses represent different error
conditions, which may be caught and handled by Java applications. The exception
may include an HDF error code, and other appropriate information, to be
used by an exception handler.</li>
<p>
<li class="li2">
<b>HDFJavaException</b> -- represents errors in the Java interface to HDF,
<i>e.g.</i>, run time exceptions such as out of memory or inability to
load required Java classes. Subclasses represent different error conditions,
which may be caught and handled by Java applications.</li>
</ul>
</ul>
Our implementation of these classes makes it possible for Java classes
to perform essentially any operation that is supported by the HDF library.
The Java code to access HDF is very similar to Fortran or C -- a sequence
of calls to the routines of the HDF interface. Of course, Java programs
will generally want to encapsulate these code sequences in more abstract
classes, which represent the data objects of interest.<p>
<h4>
2.2 Use of the HDF Java classes</h4>
The HDF Java Interface classes are intended to be used in two ways:
<ol>
<li class="li2">
The <b>HDF</b> object can be sub-classed to provide the desired interface.
For instance, the Java HDF Viewer models the data of an HDF file as a tree,
with each node containing an abstract representation of the array, image,
or annotation from the HDF file. The description of these objects could
be modelled as subclasses of <b>HDF</b>. (This can be seen as effectively
providing an easy way to extend and customize the HDF API--for better or
worse.)</li>

<p>For instance, an ``SDS object'' could be a sub class of <b>HDF</b>,
which provides methods to access a specific representation of the meta-data
and data of an <b>SDS</b> object from an HDF file. The methods of the <b>SDS</b>
object would use the appropriate native code methods of the <b>HDF</b>
superclass to access the HDF file to construct the required representation.
<li class="li2">
Alternatively, any Java class can use the <b>HDF</b> class to obtain or
create data in any way desired, in combination with any other code. For
instance, a ``HDF-EOS Grid object'' could be implemented as a Java class
with appropriate methods. The methods of the <b>HDF-EOS</b> class would
instantiate HDF objects and invoke appropriate methods to store and retrieve
data. In this model, HDF storage can be used in combination with other
services in complex objects.</li>

<p>There have been many ideas for both general and application specific
object models for data and images. For instance, [<a href="#REF19">19</a>]
is an example of a generic object model for scientific data, and the HDF
EOS model [<a href="#REF12">12</a>] is an application specific data model.
The HDF Java classes described here are the necessary foundation that allows
these kinds of models to be implemented quickly and portably using Java,
with the ability to create and use data stored in HDF.
<br></ol>

<h3>
3. Implementation</h3>
An initial implementation of the HDF Java classes has been completed. The
implementation required solution of a number of important problems that
are of general interest to any effort to interface Java and C. These include:
<ol>
<li class="li2">
Data transfer and translation between Java and C, particularly of arbitrary
multidimensional arrays of numbers.</li>

<li class="li2">
Performance issues, especially data copying</li>

<li class="li2">
Garbage collection and memory management</li>

<li class="li2">
Exceptions and errors, translating C error conditions into appropriate
Java exceptions.</li>
</ol>
These issues are discussed in this section.<p>
<h4>
3.1 Data Transfer and Translation Issues</h4><p>
Many HDF functions return several data items in addition to a return value.
That is, many of the parameters to the routines of the HDF library are
``OUT'' or ``IN/OUT'' parameters. In C this is expressed by call-by-reference
semantics, that is, using pointers. Java passes all arguments by value,
so special operations are required to return a value through a parameter.
The C code must invoke operations on arrays, or invoke methods of the other
types of objects.
<p>A very important function of HDF s handling (possibly large) multi-dimensional
arrays of numbers, with accompanying metadata. The HDF library provides
portable, self-describing data storage and access to this type of data.
HDF achieves this through the use of untyped arrays (<i>i.e.</i>, C type
``void *'', meaning ``any'') and internally converts between portable data
representations and the local native data representations. Java is, of
course, strongly typed, so the type of all arguments must be specified
in the interface or else discovered at run time. Also, the Java VM has
its own portable data representations which must be converted to and from
native data representations.
<p>Like many C interfaces, the HDF library uses structures (actually unions)
to pass related groups of parameters. For instance, HDF supports several
types of compression. Each compression algorithm has specific parameters,
for example, JPEG compression requires parameters to specify the ``quality''
and ``start_baseline''. [<a href="#REF13">13</a>,
<a href="#REF14">14</a>]
In C these parameters are passed by in a <i>union</i>, which should contain
the parameters appropriate to the selected compression algorithm. In Java,
this concept can be modelled by a <b>CompInfo</b> class, with sub-classes
for the specific cases, such as,
<b>JPEGCompInfo</b>.
<p>This data handling is, in fact, the heart of the HDF Java interface.
All of these issues are handled by a combination of special Java classes
and C-code that uses the standard Java Native Interface (JNI). [<a href="#REF7">7</a>]
The JNI provides standard functions for C programs to create, access, and
manipulate Java objects. These functions are standard across all platforms,
assuring that the C code is (in principle) portable to any JDK 1.1 implementation.
<p><b>3.1.1 Pass-By-Reference Parameters</b>
<p>The HDF library uses ``pass-by-reference'' parameters to retrieve values
from the data and metadata of an HDF file. For example, the HDF function
<b>SDfileinfo</b> returns two items of metadata as integers (Figure 1).
<p>The Java language provides classes to enable basic data types to be
passed as Objects -- the class
<b>Integer</b> wraps an <b>int</b>, and
so on. These classes can be used to pass data to C native methods. The
HDF function <b>SDfileinfo</b> can be declared as a Java native method,
e.g.,
<pre><b> public native boolean SDfileinfo(int sdid, Integer fileinfo, Integer nglobalattr);</b></pre>
This method would be invoked in a natural way, as shown in Figure 2. The
HDF library is not called directly by the Java code, a C interface is required.
An implementation of the interface method is shown in Figure 3. The native
method uses elements of the Java Native Interface (JNI) to call methods
on the Java <b>Integer</b> objects. In this case, the code calls the constructor
for the class
<b>Integer</b>, initializing the object to the value read
by the native HDF library. This effectively ``returns'' the value to the
Java object that called the native method.
<p>The JNI allows a C routine to invoke any method of any Java class, so
Java objects passed to native methods can potentially be accessed and manipulated
in many ways besides setting a value.
<p>It is very important to note that the code in Figure 3 can (in principle)
be used on any platform that supports JDK 1.1, because the JNI calls are
a required part of the JDK 1.1 standard. This means that all the code shown
here can be written once and used everywhere. Naturally, both the Java
to C code in Figure 3 and the HDF library itself must be compiled and installed
on each platform. But only one version of the C code should be required.
<p><b>3.1.2 Arrays and Strings</b>
<p>HDF is specifically designed to handle multidimensional arrays of numeric
data. The HDF interface is ``self describing'', able to handle arrays of
up to 15 dimensions, with dimensions of any length, with elements of type
<b>byte</b>, <b>short</b>, <b>int</b>, <b>float</b> or <b>double</b> (and
other types).
<p>To give a concrete example, consider the HDF function <b>SDreaddata</b>,
an HDF operation to read multi-dimensional array of numbers. (Figure 4)
<p>To access this routine from Java, a native method is declared, with
appropriate parameters. In this example, the <b>start</b>, <b>stride</b>,
and <b>edge</b> can be passed Java arrays. However, the ``OUT'' buffer
may be any shape and type of array: up to 15 dimensions, of any size, with
elements of type <b>byte</b>, <b>short</b>, <b>int</b>, <b>float</b> or
<b>double</b>. One way to deal with this is to declare the array to be
type ``byte[]'', and force the Java program to interpret the returned bytes,
for example, as a two dimensional array of floats (<b>float[][]</b>). The
second way is to declare the array type ``Object'', and to have the code
of the HDF Java Interface discover the type at run time. The HDF Java Interface
provides both options, as show in Figure 5.
<p>The Java API in Figure 5 is intentionally very similar to the C API,
and is invoked in a similar manner. Figure 6 shows an example of some Java
code that calls this interface to read a two dimensional array of floating
point numbers. This code is very similar to the equivalent C code.
<p>As discussed in the previous section, the HDF library is not called
directly by the Java object. Figure 7 gives a sketch of the implementation
of the native method declared in Figure 5. This code uses several parts
of the Java Native Interface. The ``IN'' arrays must be ``pinned'' in memory,
because the Java VM might not store an array as a contiguous array of bytes,
as expected by C. The JNI has a standard interface for this operation,
in this case, <i>GetIntArrayElements</i>. The pinned array must be released
after use, as show in this example code. The data array is handled similarly,
except that the array is written back to the Java array after it is filled
in by the HDF library (note the ``JNI_COMMIT'' argument in the call to
<i>ReleaseByteArrayElements</i>).
<p>As explained above, the JNI interface is standard, so the C code is
portable to any JDK 1.1 platform. However, the implementation of the ``pinning'',
release, and write back are platform dependent. On some platforms, this
may be implemented as simple pointer operations, on others, a data copy
may be necessary. The semantics should be identical, but the computation
time and memory use may differ across platforms.
<p><b><i>Strings</i></b>
<p>Strings are handled in analogously to the arrays shown in Figure 7.
The JNI provides functions to ``pin'' a Java String object, returning an
array of bytes for use by C. This operation must also convert from UTF
(Java) to ASCII (C). The reverse operations are also provided, to convert
a C string to a Java String, and to convert from ASCII to UTF. Most systems
will presumably require a data copy to convert between Java and C strings.
<p><b><i>Run Time Type Discovery for Multidimensional Arrays</i></b>
<p>In the example code shown in Figure 6, the class ``HDFArray'' encapsulates
methods to discover the shape, size and number type of the array at run
time, and to perform the appropriate transformations on the data. In this
example, the <b>HDFArray</b> class is used to discover the type of the
array at run time, to allocate an appropriate buffer (of type <b>byte[]</b>),
and to perform the appropriate data transformations to convert from an
array of bytes return by HDF to the equivalent two dimensional array of
floats object (<b> float[][]</b>) required by Java.
<p>The <b>HDFArray</b> class has a private class called <b>ArrayDescriptor</b>,
which illustrates how the
<i>java.lang.reflect</i> package [<a href="#REF8">8</a>]
is used to discover the shape, size, and number type of an arbitrary array
object. Given a Java array, a table is built containing a complete description
of the array. This table is then used when needed to traverse the array,
extracting or inserting data as appropriate, using data type specific methods.
Figure 8 illustrates how this table can be constructed.
<p>The <b>HDFArray</b> object has two main methods:
<ul class="ul">
<li class="li2">
<i>byteify()</i> which converts a Java array into a one dimensional array
of bytes to be used by C (Figure 9), and</li>

<li class="li2">
<i>arrayify()</i> which copies from a one dimensional array of bytes into
a Java array object (Figure 10).</li>
</ul>
It is important to point out that in these methods <i>the entire data array
is copied at least once</i>.
<p>The actual data copies are done on one dimensional arrays, using a call
to one of several native methods written in C. There is one such native
method for each basic type,
<b>byte</b>, <b>short</b>, <b>int</b>, <b>float</b>,
and <b>double</b>. This is necessary because the casting from bytes to
longer number types and vice versa is machine dependent. Java code cannot
and should not have machine dependent code in it. In any case, the necessary
byte ordering and so on is usually handled by the C compiler, so only one
version of these routines should be needed, which should do the right thing
on each particular platform. An example of this C code is shown in Figure
11.
<p>The <b>HDFArray</b> class and supporting methods provides a service
that may be used by any Java application that needs to handle arbitrary
arrays of numbers. There is nothing specific to HDF in the implementation
of this class, it could be used by any Java application that needs to handle
arrays.
<p><b>3.1.3 C Structures and Unions</b>
<p>In some cases, HDF passes related sets of parameters as a C structure
or union. In a Java program, this is represented as a class or related
set of classes. To actually call the C library routine, the Java object
must be converted into the appropriate C union. This conversion can only
be done by the Java-to-C wrapper using the JNI (because Java code simply
cannot create C unions). The C code copies the the fields of the Java object,
one by one, into the fields of the C structure. Similar code can be used
to populate a Java object from a C structure.
<p>In the case of a C <i>union</i>, the C code must convert between one
of several subclasses and one of the alternative C structures. The conversion
code consists of a <i>switch</i> statement, with cases for each possible
type of conversion. The C union is filled in by an element by element copy
from the fields of the Java object to the fields of the C union.
<p>For a C interface that uses such structures heavily, the Java-to-C wrapper
code will contain many such sequences and will be quite voluminous. Also,
C code may declare arbitrarily large and complex structures, which may
contain arrays, structures, and unions (for an example, see the <b>HDF_CHUNK_DEF</b>
used by the latest release of HDF). It is perfectly possible to express
such data structures with appropriate Java classes, and even to deal with
structures which contain C pointers, but the code to translate between
Java and C could be long and difficult to write.
<p>In HDF, a prominent example of this type of parameter passing is the
<i>comp_info</i> structure (Figure 12). HDF supports several types of data
compression, and each method may have algorithm specific input parameters.
The parameters are encapsulated in the <i>comp_info</i> union, which is
used to pass the appropriate type of information given the selected compression
method.
<p>This union can be expressed as a Java class, such as <b>HDFCompInfo</b>
(Figure 13), which is specialized by subclasses for each type of compression
supported, for example, the input parameters for JPEG compression [<a href="#REF13">13</a>,
<a href="#REF14">14</a>]
could be represented in the class <b>HDFJPEGCompInfo</b>, a subclass of
the generic <b>HDFCompInfo</b> class (Figure 14). The generic class is
uses as an argument to methods, including native methods such as:
<ol><b>public native boolean GRsetcompress(int ri_id, int comp_type, HDFCompInfo
c_info);</b></ol>
Depending on the type of compression specified, the Java program must set
<i>comp_type</i> to the appropriate value and create and initialize an
object of the appropriate subclass of <b>CompInfo</b>. These objects would
then be passed to the <b>GRsetcompress</b> native method.
<p>The native method must discover the type of compression requested and
then create the appropriate <i>comp_info</i> union. Figure 15 shows a sketch
of a subroutine which implements a simple case. The example takes as input
a Java object and an uninitialized C union, and copies the values from
the fields of the Java object to the fields of the C union. (Note that
the example code uses JNI routines to access static fields of the Java
object.) This subroutine shows a very simple case, which could be extended
to handle many alternatives, and to copy different types of data, including
nested structures and unions.
<p>The subroutine may be called by any native method that needs to use
a <b>CompInfo</b> object. Figure 16 shows an example of how this might
be called from the <b>GRsetcompress</b> native method.
<p>Clearly the code to manipulate C structures is awkward and inefficient,
especially if reasonable error checking is added. It should be noted that
this is scarcely an unprecedented problem: the Fortran interface to HDF
has had to implement similar translations, as Fortran cannot directly many
C data structures. Aside from changing the HDF API, there is no alternative
to this kind of translation when attempting to provide multi-language support.<p>
<h4>
3.2 Performance</h4><p>
All the data conversions discussed above involve data copying. As far as
I can determine, these copies are unavoidable. In fact, the majority of
the data read or written through the Java HDF API is copied by the Java-to-C
code for one reason or another. The actual amount of copying the occurs
may vary from platform to platform, as the JNI operations may be implemented
through additional (albeit hidden) data copies on some architectures (<i>e.g.</i>,
to assure correct alignment or byte order between the Java VM and the native
machine.)
<p>For large datasets, this data copying is a serious performance problem.
There are three major concerns:
<ol>
<li class="li2">
The processor is occupied doing useless work. Regardless of how ``efficiently''
this is done, data copying is still not a good use of CPU time.</li>

<li class="li2">
Memory to memory copies impact the whole system:</li>

<ol>
<li class="li2">
uses up large amounts of memory, as the data is in memory at least twice.</li>

<li class="li2">
floods the memory bus</li>

<li class="li2">
flushes memory caches</li>
</ol>

<li class="li2">
The Java VM dynamic memory management system may not support large memory
operations especially well. For instance, it may be necessary to increase
the Java VM heap size, and to manually run the garbage collector. These
contingencies may impact the overall performance of the Java VM. Also,
these effects may be platform and VM specific, producing undesirably platform
specific behavior.</li>
</ol>
It is important to note that there are two key reasons why a data copy
is needed:
<ol>
<li class="li2">
to defeat Java type checking (<i>i.e.</i>, to convert from bytes and pointers
to objects and vice versa).</li>

<li class="li2">
to assume correct data representation for the Java VM or native code, <i>i.e.</i>,
native byte order.</li>
</ol>
The first requirement is a penalty inherent in Java's tight type system,
which would be required for translating in and out of any strongly typed
language. The second requirement is a penalty inherent in the Java portable
Virtual Machine, and would be encountered by any completely portable data
representation. Thus, a data copy is a direct and unavoidable consequence
of two of the crucial assets of the Java environment. (Ironically, the
HDF library itself contains code to perform exactly these functions--sometimes
this will be an unfortunate duplication of effort.)
<p>It should be noted that the JNI support code may itself contain data
copies on some platforms. These methods are charged with doing whatever
is necessary to convert from the internal Java VM representation of data
to the correct form for C, and vice versa. In some cases, this can be accomplished
with simple and fast pointer operations, but on some architectures it may
be necessary to copy the data on each conversions. Thus, there may be even
more copies than directly specified by the application, although this will
vary across platforms.
<p><b>3.3 Garbage Collection</b>
<p>The Java virtual machine manages memory, allocating objects when they
are created, and garbage collecting unused memory when objects are unused.
The data copying described in this paper uses large amounts of memory,
as <b>Array</b> objects are created and destroyed. The Java language does
not allow the program to directly manage memory, so the allocation and
reclamation must be left int the hands of the Java Runtime system. When
the objects are large and many operations are performed, Java may expend
huge amounts of memory, in ways that are not necessarily apparent to the
application programmer.
<p>For instance, the <b>HDFArray</b> class traverses and creates multidimensional
arrays. In Java, an array is an array of objects, a multidimensional array
is an array of array objects. The methods of the <b>HDFArray</b> class
create and destroy many temporary objects as they traverse a single multidimensional
array. The result may be that the memory to store the temporary objects
amounts to many times that total size of the data.
<p>It is crucial that this memory is reclaimed promptly, so the Java garbage
collector should run as the large arrays are processed. There are three
options here:
<ol>
<li class="li2">
manually invoke garbage collection at strategic places in the HDF Java
wrapper code, such as at the end of a memory intensive method.</li>

<li class="li2">
create and start a separate Java thread to periodically invoke the garbage
collector, and</li>

<li class="li2">
create an alternative garbage collector to install in the Java runtime.</li>
</ol>
The HDF Java interface will experiment with a combination the first two
possibilities. The third possibility is being investigated, but does not
seem feasible.
<p>While the garbage collector is running, less useful computation is accomplished.
This overhead appears to be unavoidable. The Java memory management model
is designed to be simple, secure, and portable. This works acceptably for
reasonable numbers of reasonable sized objects, but becomes a performance
problem for data intensive programs handling large amounts of memory. So
again, this work has shown how important positive assets of Java have inherent
performance consequences.<p>
<h4>
3.4 Exceptions</h4><p>
The Java language provides a clean, state of the art, mechanism for raising
and handling exceptions. C has no such mechanism, but the JNI provides
access to the Java model. [<a href="#REF7">7</a>] This support allows the
Java-to-C code to detect errors reported by the native code library, and
then to create and raise appropriate exceptions. This is actually a fairly
elegant solution, allowing the Java code to be written in a natural style,
despite the fact that native code is involved.
<p>Implementation requires two steps:
<ol>
<li class="li2">
a model of the exception conditions must be constructed, defining the exceptions
that may occur, and what they mean.</li>

<li class="li2">
implement code to detect errors from the native code, and then raise the
appropriate exception.</li>
</ol>
The HDF Java API defines an exception model with two main subclasses of
exceptions,
<ol>
<li class="li2">
<b>HDFLibraryException</b> -- exceptions that indicate error conditions
reported by the native HDF library.</li>

<li class="li2">
<b>HDFJavaException</b> -- Exceptions that indicate errors in the Java
HDF wrapper code itself.</li>
</ol>
The former is basically a representation of the error codes from HDF. This
exception class can be subclassed to capture natural structure in the HDF
error conditions, although this has not yet been done. The latter errors
may occur in the the JNI calls and the code that implements the data translation
and copying. In the future, this subclass, too, may be subclassed to reflect
important categories of errors. Figure 17 shows a sketch of the <b>HDFLibraryException</b>
class.
<p>Any native method that will raise an exception will need to be declared,
for instance,
<pre><b> public native int Hopen(String filename, int access) throws HDFException ;</b></pre>
which is exactly the same for a native method as for any other.
<p>The code to implement the native method must include C code to test
for errors, and then call JNI methods to raise an exception. Figure 18
shows a sketch of the code to implement the
<b>Hopen</b> native method.
Both of the classes of HDF exception are illustrated in this example.
<p>If the JNI call to <b>GetStringUTFChars</b> fails-- if a NULL String
is used or due to insufficient memory-- an <b>HDFJavaException</b> object
is created and thrown. In a few cases, the JNI itself may raise an exception.
If so, then this error may be caught and cleared by the C code, in order
to raise a different exception.
<p>The second exception may occur if the call to the HDF library fails--if,
for instance, the file does not exist and is being opened for reading.
The HDF library call will return <b>FAIL</b>, and, if applicable, there
will be error information which can be retrieved by the <b>HEvalue</b>
call. (See the HDF manuals for more information about HDF error handling.
[<a href="#REF2">2</a>,
<a href="#REF3">3</a>] )
<p>The example in Figure 18 shows one way to deal with these errors. If
the <b>Hopen</b> call fails, and an error code is set, then an <b>HDFLibraryException</b>
is thrown, setting the exception message to the standard message returned
by the <b>HEstring</b> call.
<p>Figure 19 shows an example of Java code that uses the native method
shown in this example. The invocation of the <b>Hopen</b> is enclosed in
a ``try/catch'' block, and the code in the ``catch'' block is executed
if one of the exceptions is raised. In the example in Figure 19, if the
file ``nosuchfile'' does not exist, then an exception is raised and the
message
<pre>&nbsp;&nbsp; nosuchfile: HDFLibraryException: Error opening file</pre>
is printed.
<p>The example shown here gives a simple sketch of what can be done with
the Java exception handling and JNI. These mechanisms are very flexible
and powerful, so there are many possibilities which have yet to be explored
in the HDF Java Interface. Future extensions may include:
<ol>
<li class="li2">
A more elaborate exception model, with more subclasses of Exceptions reflecting
different categories of errors. This is especially attractive if some classes
of errors can be automatically handled by some programs, perhaps adjusting
the parameters to fit the actual range, breaking up large requests into
a series of smaller ones.</li>

<li class="li2">
Perhaps add code to handle some exceptions in Java interface code itself.</li>

<li class="li2">
More elaborate reporting, especially when HDF returns a stack of errors.
In general, the error conditions from HDF could be analyzed and filtered,
with the HDF Java Interface either masking some failures (<i>e.g.</i>,
through retries or reasonable defaults) or raising very specific exceptions.
This would reduce the need for the application itself to process the exceptions
returned.</li>
</ol>
<p>
<h3>
4. Summary and Conclusions</h3><p>
The implementation described in this paper shows that the JDK 1.1 contains
most of the features needed to interface even to a complex, non-object
oriented native library such as HDF. However, the HDF Java Interface is
far from trivial, and it remains to be seen if it will be useful for many
applications.
<p>Performance is of particular concern for HDF and scientific computing
in general. The performance issues discussed in this paper appear to be
inevitable consequences of the technologies that provide the portability
and security of Java. These penalties are not significant for many applications,
but become very significant for data intensive computing, as is essential
for scientific computing. It is important to realize that Just In Time
compiler technology will have little impact on the data copying and memory
management issues which are the crux of the problem for the Java HDF Interface.
<p><b><i>Usage of the HDF Java Interface</i></b>
<p>The HDF Java Interface provides the basic access to HDF files, making
it possible for Java applications to create, modify, and read data using
the HDF library. This has already been used in our Java-based HDF Viewer,
and in a collaborative version of the viewer. [<a href="#REF4">4</a>] We
are studying using Java servers to serve data from HDF files, using an
extensible Web server such as Jigsaw [<a href="#REF15">15</a>] and/or the
Java Remote Method Invocation (RMI) [<a href="#REF16">16</a>,
<a href="#REF17">17</a>]
client/server distributed object model. Ultimately, Java might be used
to implement a Scientific Data Server, such as proposed in [<a href="#REF11">11</a>].
<p>Another potential use for the HDF Java Interface is to provide a data
exchange mechanism for Java applications. The Java Object Serialization
package [<a href="#REF18">18</a>] is designed for transporting and exchanging
objects. However, it is not well suited for extremely large objects, and
is not intended as a means for accessing objects in external storage. In
particular, the Java Object Serialization provides no no way to selectively
read or write a small part of a large object, or to read or write particular
objects out of a complex object. HDF is specifically designed for this
case, is much better suited for accessing storage, especially for scientific
data.
<p>One use of the HDF Java Interface would be for Java applications which
export important data by compactly and efficiently storing its representation
using HDF. HDF's compression and chunking features may be very useful in
this application. This external representation can then be transported
as an HDF file to other platforms, taking advantage of HDF's portability.
The stored representation can be accessed in different ways, perhaps using
chunking and parallel I/O access.
<p>Notably, the data can be read from HDF into objects of different classes
than the original data. For instance, a sub-set (<i>e.g.</i>, a hyperslab
from a multidimensional dataset) of the original dataset could be read
into a Java object representing the data of interest. With the Java Object
Serialization, entire data array must be read into memory and then the
subset may be extracted extracting.
<p>Consider, for instance, a simulation that produces a large multidimensional
dataset for each of a series of time steps. The data for each time step
would be represented as a complex Java object containing more elementary
objects. This could be stored as an HDF file, with the data stored in arrays
and tables.
<p>A visualization program may wish to access a small part of this data,
perhaps only part of the data array, or some of the variables. A Java application
could define classes to represent the selected view of the data, which
might be substantially different from the object model of the original
simulation. The visualization application could read from HDF to create
the objects needed, reading only the parts of the data needed.
<p>The performance of Java may limit its use for some aspects of scientific
computing. For instance, it is unlikely that Java would be sueful for the
inner loop of a large numeric computation. However, Java will be very useful
for portable interfaces, remote data access, and for visualization. It
is likely that there will be many hybrid environments that use Java as
a framework for interactive computing, liking to specialized native code
applications and libraries for efficient computation. Here again, the ability
to use HDF will be valuable as a means to exchange data among programs
written in different languages, as well as running on different networks.
<p>
<h3>
Acknowledgements</h3>
<b><i>This work was supported by Project Horizon, a cooperative agreement
between the University of Illinois and NASA.
<a href="http://horizon.ncsa.uiuc.edu/">(http://horizon.ncsa.uiuc.edu/horizon/)</a></i></b>
<p><b><i>Other funding was provided byt the Digital Library Initiative
at the University of Illinois. (<a href="http://dli.grainger.uiuc.edu/">
http://dli.grainger.uiuc.edu</a>) The UIUC DLI is a recipient of a grant
in the
<a href="http://stis.nsf.gov/start.htm">NSF</a>/
<a href="http://www.arpa.mil/">DARPA</a>/
<a href="http://www.nasa.gov/NASA_homepage.html">NASA</a><a href="http://www.cise.nsf.gov/iris/DLHome.html">Digital
Libraries Initiative</a>.</i></b>
<p><b><i>Robert E. McGrath<a href="mailto:mcgrath@ncsa.uiuc.edu">(mcgrath@ncsa.uiuc.edu)</a>
is part of the professional staff of the Software Development Division
of the <a href="http://www.ncsa.uiuc.edu/">National Center for Supercomputing
Applications (NCSA)</a>, at the <a href="http://www.uiuc.edu">University
of Illinois, Urbana-Champaign</a>. NCSA is funded in part by the National
Science Foundation, the Advance Research Projects Agency, corporate partners
and the state and University of Illinois.</i></b>
<p>
<h3>
References</h3>

<ol>
<li class="li2">
<a NAME="REF1"></a>NCSA, ``The HDF Home Page'',
<a href="/">/</a></li>

<li class="li2">
<a NAME="REF2"></a>NCSA, ``The <a href="ftp://ftp.ncsa.uiuc.edu/HDF/Documentation/HDF4.0r2/Compressed_Files/">HDF
User's Guide'' in Postscript, MIF, and PDF</a>* format</li>

<li class="li2">
<a NAME="REF3"></a>NCSA, ``The HDF Reference Manual'' in
<a href="ftp://ftp.ncsa.uiuc.edu/HDF/Documentation/HDF4.0r2/Ref_Manual/">Postscript,
MIF, PDF</a>*, and <a href="ftp://ftp.ncsa.uiuc.edu/HDF/Documentation/HDF4.0r2/Ref_Manual/html">HTML</a>
format.</li>

<li class="li2">
<a NAME="REF4"></a>NCSA, ``NCSA Java-based HDF Viewer'',
<a href="/hdf/java/docs/">/hdf/java/docs/</a></li>

<li class="li2">
<a NAME="REF5"></a>JavaSoft, ``The Java Development Kit, Version 1.0.2''
<a href="http://java.sun.com/products/jdk/1.0.2/index.html">http://java.sun.com/products/jdk/1.0.2/index.html</a></li>

<li class="li2">
<a NAME="REF6"></a>JavaSoft, ``The Java(TM) Development Kit, Version 1.1''
<a href="http://java.sun.com/products/jdk1.1/index.html">http://java.sun.com/products/jdk1.1/index.html</a></li>

<li class="li2">
<a NAME="REF7"></a>JavaSoft,
<b>Java Native Interface Specification: Release
1.1</b><a href="ftp://ftp.javasoft.com/docs/jdk1.1/jni.pdf">(ftp://ftp.javasoft.com/docs/jdk1.1/jni.pdf)
(PDF)</a><a href="ftp://ftp.javasoft.com/docs/jdk1.1/jni.ps">(ftp://ftp.javasoft.com/docs/jdk1.1/jni.ps)
(PS)</a></li>

<li class="li2">
<a NAME="REF8"></a>JavaSoft,
<b>Java(TM) Core Reflection Specification:
API and Specification</b><a href="ftp://ftp.javasoft.com/docs/jdk1.1/java-reflection.pdf">(ftp://ftp.javasoft.com/docs/jdk1.1/java-reflection.pdf)
(PDF)</a><a href="ftp://ftp.javasoft.com/docs/jdk1.1/java-reflection.ps">(ftp://ftp.javasoft.com/docs/jdk1.1/java-reflection.ps)
(PS)</a></li>

<li class="li2">
<a NAME="REF9"></a>JavaSoft, ``JavaBeans(TM) Component APIs for Java'',
<a href="http://splash.javasoft.com/beans/index.html">http://splash.javasoft.com/beans/index.html</a></li>

<li class="li2">
<a NAME="REF10"></a>Robert E. McGrath, ``How does HDF mix with Java?'',
<a href="/horizon/java-and-hdf.html">/horizon/java-and-hdf.html</a></li>

<li class="li2">
<a NAME="REF11"></a>Robert E. McGrath, ``A Scientific Data Server: The
Conceptual Design'',
<a href="/horizon/DataServer/sds_design.html">/horizon/DataServer/sds_design.html</a></li>

<li class="li2">
<a NAME="REF12"></a>NASA EOSDIS, ``EOSDIS Information Architecture Documents'',
<a href="http://spsosun.gsfc.nasa.gov/InfoArch_docs.html">http://spsosun.gsfc.nasa.gov/InfoArch_docs.html</a></li>

<li class="li2">
<a NAME="REF13"></a>International Standards Organization
,
<i>Digital Compression
and Coding of Continuous Still Images, Part 1</i>, Document number ISO/IEC
IS 10918-1.</li>

<li class="li2">
<a NAME="REF14"></a>James A. Murray and William vanRyper,
<i>Encyclopedia
of Graphic File Formats</i>, O'Reilly &amp; Associates, Sebastopol, CA,
1994.</li>

<li class="li2">
<a NAME="REF15"></a>W3C, ``Jigsaw Overview'',
<a href="http://www.w3.org/pub/WWW/Jigsaw/">http://www.w3.org/pub/WWW/Jigsaw/</a></li>

<li class="li2">
<a NAME="REF16"></a>JavaSoft,
<b>Java(TM) RMI Tutorial</b><a href="ftp://ftp.javasoft.com/docs/jdk1.1/rmi-getstart.pdf">(ftp://ftp.javasoft.com/docs/jdk1.1/rmi-getstart.pdf)
(PDF)</a><a href="ftp://ftp.javasoft.com/docs/jdk1.1/rmi-getstart.ps">(ftp://ftp.javasoft.com/docs/jdk1.1/rmi-getstart.ps)
(PS)</a></li>

<li class="li2">
<a NAME="REF17"></a>JavaSoft,
<b>Java(TM) Remote Method Invocation Specification</b><a href="ftp://ftp.javasoft.com/docs/jdk1.1/rmi-spec.pdf">(ftp://ftp.javasoft.com/docs/jdk1.1/rmi-spec.pdf)
(PDF)</a><a href="ftp://ftp.javasoft.com/docs/jdk1.1/rmi-spec.ps">(ftp://ftp.javasoft.com/docs/jdk1.1/rmi-spec.ps)
(PS)</a></li>

<li class="li2">
<a NAME="REF18"></a>JavaSoft,
<b>Java(TM) Object Serialization Specification</b><a href="ftp://ftp.javasoft.com/docs/jdk1.1/serial-spec.pdf">(ftp://ftp.javasoft.com/docs/jdk1.1/serial-spec.pdf)
(PDF)</a><a href="ftp://ftp.javasoft.com/docs/jdk1.1/serial-spec.ps">(ftp://ftp.javasoft.com/docs/jdk1.1/serial-spec.ps)
(PS)</a></li>

<li class="li2">
<a NAME="REF19"></a>Russ Rew, ``NetCDF C++ Interface'',
<a href="http://www.unidata.ucar.edu/packages/netcdf/cxxdoc_toc.html">http://www.unidata.ucar.edu/packages/netcdf/cxxdoc_toc.html</a></li>

<br>
<p></ol>

<h3>
Figures</h3>

<table BORDER WIDTH="650" >
<tr>
<td>
<pre><b>intn SDfileinfo(int32 sd_id, int32 *ndatasets, int32 *nglobal_attr)</b>

</pre>
where the parameters are:
<pre> sd_id
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IN:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The SD interface identifier returned from SDstart
 ndatasets
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OUT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Number of data sets in the file
 nglobal_attr
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OUT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Number of global attributes in the file&nbsp;

</pre>
</td>
</tr>
</table>

<p><b>Figure 1. The HDF function SDfileinfo which had two pass by reference
parameters.</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; import ncsa.hdf.*;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HDF hdfinterface = new HDF();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sdsid;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* initialize the HDF library with appropriate calls
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to Hopen, SDcreate, etc. */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* the parameters to be read, initialized to -1 */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer ndatasets = new Integer(-1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer nglobal_attr = new Integer(-1);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean rval =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hdfinterface.SDfileinfo(sdsid, ndatasets, nglobal_attr);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* rval has the success/failure code */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ndatasets ="+ndatasets.intValue());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("nclobal_attr ="+nclobal_attr.intValue());

</pre>
</td>
</tr>
</table>

<p><b>Figure 2. Java code to call the native method shown in Figure 1.</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>
jint Java_ncsa_hdf_HDFSDS_SDfileinfo__ILJava_lang_Integer_2LJava_...
( JNIEnv *env,
jobject obj, /* this */
jint sdid,
jobject ndatasets,&nbsp; /* OUT: Integer */
jobject nglobalattr)&nbsp; /* OUT: Integer */
{
int32 retVal;
int32&nbsp; ndataset;
int32&nbsp; nattr;
jmethodID jmi;
jclass jc;
int args[2];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* call HDF library, read into C variables */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retVal = SDfileinfo((int32)sdid, &amp;ndataset, &amp;nattr);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* check for errors, raise exception (omitted) */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (retVal == FAIL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return JNI_FALSE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* store values C variables int to Java Objects */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc = (*env)->FindClass(env, "java/lang/Integer");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (jc == NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmi = (*env)->GetMethodID (env, jc, "<init>", "(I)V");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (jmi == NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args[0] = ndataset;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args[1] = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*env)->CallVoidMethodV( env, ndatasets, jmi, args );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args[0] = nattr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*env)->CallVoidMethodV( env, nglobalattr, jmi, args );

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return JNI_TRUE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}

</pre>
</td>
</tr>
</table>

<p><b>Figure 3. The C code to implement the HDF SDfileinfo call: two integers
are read from HDF, and the appropriate Java Integer objects are initialized
to the returned values.</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>
<b> intn SDreaddata(int32 sds_id, int32 start[], int32 stride[],&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32 edge[], VOIDP buffer)</b></pre>
where the parameters are:
<pre> sds_id
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IN:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The data set identifier returned from SDselect
 start
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IN:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Array specifying the starting location in each
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dimension
 stride
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IN:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Array specifying the number of values to skip along&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; each dimension
 edge
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IN:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Array specifying the number of values to read along&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; each dimension
 buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OUT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Buffer to store the data, sufficient space must be
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocated by the caller

 Returns: SUCCEED (or 0) if successful and FAIL (or
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1) otherwise.</pre>
</td>
</tr>
</table>

<p><b>Figure 4. The HDF function SDreaddata().</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>public native boolean SDreaddata(&nbsp; int sdsid, int[] start,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int[] stride, int[] count,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] data);

public boolean SDreaddata(&nbsp; int sdsid, int[] start,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int[] stride, int[] count,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object theData )&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] data;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean rval;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* discover the shape, size, and type of the array */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HDFArray theArray = new HDFArray(theData);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* allocate a buffer of bytes */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = theArray.emptyBytes();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Call the native method above */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rval= SDreaddata(&nbsp; sdsid, start, stride, count, data);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Convert the bytes into the appropriate Java objects */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theData = theArray.arrayify( data );

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return rval;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</pre>
</td>
</tr>
</table>

<p><b>Figure 5. A Java interface for the The HDF function SDreaddata().</b>
The second version discovers the shape of the array at run time.
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; import ncsa.hdf.*;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HDF hdfinterface = new HDF();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sdsid;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* initialize the HDF library with appropriate calls
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to Hopen, SDcreate, etc. */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int start = new int[2];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int count = new int[2];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* discover the shape of the array using appropriate
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HDF calls, fill in the start and count */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float f[][] = new float[100][50];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean rval =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hdfinterface.SDreaddata(sdsid, start, null, count, f);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* rval has the success/failure code */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* f&nbsp;&nbsp;&nbsp; has the data read from the file */

</pre>
</td>
</tr>
</table>

<p><b>Figure 6. A sample of Java code to call the HDF function SDreaddata()
using the interface in Figure 2.</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>
#include &amp;lthdf.h>
#include &amp;ltjni.h>

jboolean Java_ncsa_hdf_HDF_SDreaddata__I_3I_3I_3I_3B
( JNIEnv *env,&nbsp; /* a la the JNI interface */
jobject obj,&nbsp;&nbsp;&nbsp; /* a la the JNI interface */
jint sdsid,&nbsp;&nbsp;&nbsp;&nbsp; /* IN: int */
jarray start,&nbsp;&nbsp; /* IN: int[] */
jarray stride,&nbsp; /* IN: int[] */
jarray count,&nbsp;&nbsp; /* IN: int[] */
jarray data)&nbsp;&nbsp;&nbsp; /* OUT: byte[], data for a multidimensional&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array&nbsp; */
{
&nbsp; int32 retVal;
&nbsp; int32 *strt;
&nbsp; int32 *strd;
&nbsp; int32 *cnt;
&nbsp; char *d;

&nbsp; /* most error checking omitted for brevity */
&nbsp; strt = (*env)->GetIntArrayElements(env,start,NULL);
&nbsp; if (stride != NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strd = (*env)->GetIntArrayElements(env,stride,NULL);
&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strd = NULL;
&nbsp; }
&nbsp; cnt = (*env)->GetIntArrayElements(env,count,NULL);

&nbsp; /* Important: check that 'data' is big enough ! */
&nbsp; d = (*env)->GetByteArrayElements(env,data,NULL);

&nbsp; /*
&nbsp;&nbsp; *&nbsp; Call the HDF library
&nbsp;&nbsp; */
&nbsp; retVal = SDreaddata((int32)sdsid, strt, strd, cnt, d);

&nbsp; /* check for error from library, throw exception (omitted) */

&nbsp; (*env)->ReleaseIntArrayElements(env,start,strt,JNI_ABORT);
&nbsp; if (stride != NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*env)->ReleaseIntArrayElements(env,stride,strd,JNI_ABORT);
&nbsp; }
&nbsp; (*env)->ReleaseIntArrayElements(env,count,cnt,JNI_ABORT);

&nbsp; if (retVal == FAIL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* don't write back if call failed */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*env)->ReleaseByteArrayElements(env,data,d,JNI_ABORT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return JNI_FALSE;
&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* write back the data that was read:&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the bytes from C will be converted into a Java
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array of bytes (byte[]) */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*env)->ReleaseByteArrayElements(env,data,d,JNI_COMMIT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return JNI_TRUE;
&nbsp; }
}</pre>
</td>
</tr>
</table>

<p><b>Figure 7. The Java-C interface code to call the HDF function SDreaddata()
using the Java Native Method Interface.</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>
 package java.lang.reflect.*;
 package ncsa.hdf;

 class ArrayDescriptor {

&nbsp;&nbsp; /* some code omitted to save space */
&nbsp;&nbsp; static int [] dimlen = null;
&nbsp;&nbsp; static int [] bytetoindex = null;
&nbsp;&nbsp; static int totalSize = 0;
&nbsp;&nbsp; static char NT = ' ';&nbsp; /*&nbsp; must be B,S,I,L,F,D, else error */
&nbsp;&nbsp; static int NTsize = 0;
&nbsp;&nbsp; static int dims = 0;

&nbsp;&nbsp; public ArrayDescriptor ( Object anArray ) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class tc = anArray.getClass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tc.isArray() == false) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Raise exception: not an array */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* parse the type descriptor to discover the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shape of the array */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String ss = tc.toString();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int n = 6;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dims = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (n &lt; ss.length()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NT = ss.charAt(n);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (NT == '[') {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dims++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; must be B,S,I,L,F,D, else error */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (NT == 'B') {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NTsize = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (NT == 'S') {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NTsize = 2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ((NT == 'I') || (NT == 'F')) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NTsize = 4;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ((NT == 'J') || (NT == 'D')){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NTsize = 8;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Raise exception:&nbsp; not a numeric type */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* fill in the table */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dimlen = new int [dims+1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bytetoindex = new int [dims+1];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object o = anArray;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objs[0] = o;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dimlen[0]= 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( i = 1; i &lt;= dims; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dimlen[i] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java.lang.reflect.Array.getLength((Object) o);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o = java.lang.reflect.Array.get((Object) o,0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int j;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int dd;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bytetoindex[dims] = NTsize;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( i = dims; i >= 0; i--) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dd = NTsize;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (j = i; j &lt; dims; j++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dd *= dimlen[j + 1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bytetoindex[i] = dd;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; totalSize = bytetoindex[0];
&nbsp;&nbsp; }

}</pre>
</td>
</tr>
</table>

<p><b>Figure 8. Java code to discover the shape and type of an arbitrary
array using the <i>java.reflect.Array</i> package.</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre> package ncsa.hdf;
/*
 * flatten a Java array into a one-dimensional array of&nbsp;
 * bytes with native byte ordering.
 */

 public byte[] byteify(){

&nbsp;&nbsp; /* check parameters, and if already is one dimension is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a special case....omitted here */

&nbsp;&nbsp; Object oo = _theArray;
&nbsp;&nbsp; n = 0;&nbsp; /* the current byte */
&nbsp;&nbsp; int index = 0;
&nbsp;&nbsp; int i;
&nbsp;&nbsp; while ( n &lt; _desc.totalSize ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oo = _desc.objs[0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index = n / _desc.bytetoindex[0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index %= _desc.dimlen[0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0 ; i &lt; (_desc.dims); i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index = n / _desc.bytetoindex[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index %= _desc.dimlen[i];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (index == _desc.currentindex[i]) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* then use cached copy */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oo = _desc.objs[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* check range of index */&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (index > (_desc.dimlen[i] - 1)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("out of bounds?");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oo = java.lang.reflect.Array.get((Object)oo,index);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _desc.currentindex[i] = index;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _desc.objs[i] = oo;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* byte-ify */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte arow[];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_desc.NT == 'F') {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; Call a C routine to copy the row
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arow = floatToByte(0,_desc.dimlen[_desc.dims],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (float [])_desc.objs[_desc.dims - 1]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (_desc.NT == 'I') {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* other types are similar ... */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; A second data copy here (is this necessary?)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.arraycopy(arow,0,_barray,n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (_desc.dimlen[_desc.dims] * _desc.NTsize));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n += _desc.bytetoindex[_desc.dims - 1];

&nbsp;&nbsp; }

&nbsp;&nbsp; /* error checks&nbsp; omitted */
&nbsp;&nbsp; return _barray;
}</pre>
</td>
</tr>
</table>

<p><b>Figure 9. Java code to convert an arbitrary array to a contiguous
array of bytes a la C. This code uses the <i>java.reflect.Array</i> package.</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>
&nbsp; /* give an array of bytes, fill in the Java array */

 public Object arrayify(byte[] bytes){

&nbsp;&nbsp; /* error checks omitted */
&nbsp;&nbsp; _barray = bytes; /* hope that the bytes are correct.... */

&nbsp;&nbsp; /* One dimensional array is special case -- omitted */

&nbsp;&nbsp; Object oo = _theArray;
&nbsp;&nbsp; int n = 0;&nbsp; /* the current byte */
&nbsp;&nbsp; int index = 0;
&nbsp;&nbsp; int i;
&nbsp;&nbsp; while ( n &lt; _desc.totalSize ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oo = _desc.objs[0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index = n / _desc.bytetoindex[0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index %= _desc.dimlen[0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0 ; i &lt; (_desc.dims); i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index = n / _desc.bytetoindex[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index %= _desc.dimlen[i];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (index == _desc.currentindex[i]) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* then use cached copy */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oo = _desc.objs[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* check range of index */&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (index > (_desc.dimlen[i] - 1)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("out of bounds?");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oo = java.lang.reflect.Array.get((Object) oo,index);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _desc.currentindex[i] = index;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _desc.objs[i] = oo;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* byte-ify */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_desc.NT == 'F') {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; Call a C routine to copy the row
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float arow[] = byteToFloat(n,_desc.dimlen[_desc.dims],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _barray);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; Insert new row in the array (this might cause
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; a data copy in some implementations
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java.lang.reflect.Array.set(_desc.objs[_desc.dims - 2] ,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (_desc.currentindex[_desc.dims - 1]), (Object)arow);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n += _desc.bytetoindex[_desc.dims - 1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _desc.currentindex[_desc.dims - 1]++;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (_desc.NT == 'I') {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* other types are similar... */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp; }

&nbsp;&nbsp; /* error checks omitted */

&nbsp;&nbsp; return _theArray;
 }</pre>
</td>
</tr>
</table>

<p><b>Figure 10. Java code to convert a contiguous array of bytes (a la
C) into an appropriate Java array object. This code uses the <i>java.reflect.Array</i>
package.</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* HDFArray uses C code to copy arrays by row */

 public native byte[] intToByte( int start, int len,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int[] data);
 public native byte[] shortToByte( int start, int len,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short[] data);
 public native byte[] floatToByte( int start, int len,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float[] data);
 public native byte[] longToByte( int start, int len,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long[] data);
 public native byte[] doubleToByte( int start, int len,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] data);

</pre>
</td>
</tr>

<tr>
<td>
<pre>
&nbsp;&nbsp;&nbsp; /*&nbsp; The native method looks something like this: */

 /* returns float [] */
 jarray Java_ncsa_hdf_HDFArray_byteToFloat__II_3B
 ( JNIEnv *env,
 jobject obj, /* this */
 jint start,
 jint len,
 jarray bdata)&nbsp; /* IN: array of bytes */
 {
&nbsp;&nbsp; intn rval;
&nbsp;&nbsp; char *bp;
&nbsp;&nbsp; jbyte *barr;
&nbsp;&nbsp; jarray rarray;
&nbsp;&nbsp; int blen;
&nbsp;&nbsp; jfloat *iarray;
&nbsp;&nbsp; jfloat *iap;
&nbsp;&nbsp; int ii;

&nbsp;&nbsp; /* pin the Java byte array (the source) */

&nbsp;&nbsp; if (bdata == NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Exception: bdata is NULL?\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;
&nbsp;&nbsp; }
&nbsp;&nbsp; barr = (*env)->GetByteArrayElements(env,bdata,NULL);
&nbsp;&nbsp; if (barr == NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Exception: GetByteArrayElements failed? */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;
&nbsp;&nbsp; }

&nbsp;&nbsp; blen = (*env)->GetArrayLength(env,bdata);
&nbsp;&nbsp; if ((start &lt; 0) ||&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((start + (len*(sizeof(jfloat)))) > blen)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; Exception: start or len is out of bounds? */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;
&nbsp;&nbsp; }

&nbsp;&nbsp; bp = (char *)barr + start;

&nbsp;&nbsp; /* allocate a new java float array (the destination) */
&nbsp;&nbsp; rarray = (*env)->NewFloatArray(env,len);
&nbsp;&nbsp; if (rarray == NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; Exception: NewFloatArray failed? */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;
&nbsp;&nbsp; }

&nbsp;&nbsp; iarray = (*env)->GetFloatArrayElements(env,rarray,NULL);
&nbsp;&nbsp; if (iarray == NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Exception: GetFloatArrayElements failed? */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;
&nbsp;&nbsp; }

&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp; *&nbsp; Copy using C:&nbsp; byte ordering, etc., is handled
&nbsp;&nbsp;&nbsp; *&nbsp; by the C compiler.
&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp; iap = iarray;
&nbsp;&nbsp; for (ii = 0; ii &lt; len; ii++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *iap = *(jfloat *)bp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iap++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bp += sizeof(jfloat);
&nbsp;&nbsp; }

&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp; *&nbsp; Write back the results
&nbsp;&nbsp;&nbsp; */

&nbsp;&nbsp; (*env)->ReleaseFloatArrayElements(env,rarray,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (jfloat *)iarray, JNI_COMMIT);
&nbsp;&nbsp; (*env)->ReleaseByteArrayElements(env,bdata,barr,JNI_COMMIT);

&nbsp;&nbsp; return rarray;

}

</pre>
</td>
</tr>
</table>

<p><b>Figure 11. Example C code to copy from C to Java. This uses the Java
Native Interface (JNI) to manipulate the Java array.</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>
typedef union tag_comp_info
 {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; struct
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intn&nbsp;&nbsp;&nbsp; quality;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intn&nbsp;&nbsp;&nbsp; force_baseline;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; jpeg;
&nbsp;&nbsp;&nbsp;&nbsp; struct
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32&nbsp;&nbsp; nt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intn&nbsp;&nbsp;&nbsp; sign_ext;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intn&nbsp;&nbsp;&nbsp; fill_one;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intn&nbsp;&nbsp;&nbsp; start_bit;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intn&nbsp;&nbsp;&nbsp; bit_len;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; nbit;
&nbsp;&nbsp;&nbsp;&nbsp; struct
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intn&nbsp;&nbsp;&nbsp; skp_size;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; skphuff;
&nbsp;&nbsp;&nbsp;&nbsp; struct
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intn&nbsp;&nbsp;&nbsp; level;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp; deflate;
 }
comp_info;</pre>
</td>
</tr>
</table>

<p><b>Figure 12. The HDF ``comp_info'' union, used to pass parameters required
by different compression algorithms. (From hcomp.h)</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>
package ncsa.hdf;


public class HDFCompInfo {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static int ctype;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public HDFCompInfo() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctype = HDFConstants.COMP_CODE_NONE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } ;

}</pre>
</td>
</tr>
</table>

<p><b>Figure 13. A Java class for generic compression information.</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>
package ncsa.hdf;


public class HDFJPEGCompInfo extends HDFCompInfo {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Struct to contain information about how to compress */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* or decompress a JPEG encoded 24-bit image */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static public int&nbsp;&nbsp;&nbsp; quality;&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static public int&nbsp;&nbsp;&nbsp; force_baseline;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public HDFJPEGCompInfo() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctype = HDFConstants.COMP_JPEG;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

}</pre>
</td>
</tr>
</table>

<p><b>Figure 14. A Java class encapsulating the input parameters used byt
JPEG compression.</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>

 #include "hdf.h"
 #include "hfile.h"
 #include "hcomp.h"

 #include "jni.h"

 jboolean getCompInfo( JNIEnv *env, jobject obj, comp_info *cinf)
 {
 jfieldID jf;
 jclass jc;
 jint ctype;
&nbsp;
&nbsp;&nbsp; /* Read the compression type from the Java object */
&nbsp;&nbsp; jc = (*env)->FindClass(env, "ncsa/hdf/HDFCompInfo");
&nbsp;&nbsp; if (jc == NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* exception */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return JNI_FALSE;
&nbsp;&nbsp; }
&nbsp;&nbsp; jf = (*env)->GetStaticFieldID(env, jc, "ctype", "I");
&nbsp;&nbsp; if (jf == NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* exception */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return JNI_FALSE;
&nbsp;&nbsp; }
&nbsp;&nbsp; ctype = (*env)->GetStaticIntField(env, jc, jf);

&nbsp;&nbsp; /* based on the type, the sub class of the object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is known, and so copy the fields.&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Only JPEG is shown. */
&nbsp;&nbsp; switch(ctype) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case COMP_NONE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case COMP_RLE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case COMP_IMCOMP:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* omitted */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case COMP_JPEG:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Use the HDFJPEGCompInfo class, copy two fields */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc = (*env)->FindClass(env, "ncsa/hdf/HDFJPEGCompInfo");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (jc == NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return JNI_FALSE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jf = (*env)->GetStaticFieldID(env, jc, "quality", "I");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (jf == NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return JNI_FALSE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cinf->jpeg.quality =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*env)->GetStaticIntField(env, jc, jf);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jf =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*env)->GetStaticFieldID(env, jc, "force_baseline", "I");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (jf == NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return JNI_FALSE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cinf->jpeg.force_baseline =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*env)->GetStaticIntField(env, jc, jf);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp; }

&nbsp;&nbsp; return JNI_TRUE;
}

</pre>
</td>
</tr>
</table>

<p><b>Figure 15. A sketch of C-code to translate from a Java CompInfo object
to a C comp_info union.</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>
 jboolean Java_ncsa_hdf_HDFGR_GRsetcompress
 ( JNIEnv *env,
 jobject obj, /* this */
 jint ri_id,&nbsp;
 jint comp_type,&nbsp;
 jobject c_info) /* IN:&nbsp; CompInfo */
 {
&nbsp;&nbsp; intn rval;
&nbsp;&nbsp; comp_info cinf;
&nbsp;&nbsp; jboolean bval;

&nbsp;&nbsp; /* Fill in the appropriate parts of the comp_info
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure. */
&nbsp;&nbsp; bval = getCompInfo(env,obj,&amp;cinf);

&nbsp;&nbsp; /* check for success... */

&nbsp;&nbsp; /* call HDF */

&nbsp;&nbsp; rval = GRsetcompress((int32) ri_id, (int32) comp_type,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (comp_info *)&amp;cinf);

&nbsp;&nbsp; if (rval == FAIL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* check for errors */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return JNI_FALSE;
&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return JNI_TRUE;
&nbsp;&nbsp; }
 }

</pre>
</td>
</tr>
</table>

<p><b>Figure 16. Example of a native method that uses a CompInfo object,
and passes a comp_info union to HDF.</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>
public class HDFLibraryException extends HDFException {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int HDFerror;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String msg;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public HDFLibraryException() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HDFerror = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public HDFLibraryException(String s) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg = "HDFLibraryException: "+s;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public HDFLibraryException(int err) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HDFerror = err;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public String getMessage() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return msg;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
}</pre>
</td>
</tr>
</table>

<p><b>Figure 17. A simple implementation of the Java Class HDFLibraryException</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>
jint Java_ncsa_hdf_HDF_Hopen(
JNIEnv *env,
jobject obj, /* this */
jstring hdfFile,
jint access)
{
&nbsp;&nbsp; char* file;
&nbsp;&nbsp; int&nbsp; retVal;
&nbsp;&nbsp; int errval;
&nbsp;&nbsp; jclass jc;

&nbsp;&nbsp; file =(char *) (*env)->GetStringUTFChars(env,hdfFile,0);

&nbsp;&nbsp; if (file == NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* JNI call failed */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*env)->FindClass(env, "ncsa/hdf/HDFJavaException");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (jc == NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1; /* exception is raised */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*env)->ThrowNew(env,jc,"Hopen: GetStringUTFChars failed");
&nbsp;&nbsp; }

&nbsp;&nbsp; /* open HDF file specified by ncsa_hdf_HDF_file */
&nbsp;&nbsp; retVal = Hopen((char *)file, access, 0);
&nbsp;&nbsp; (*env)->ReleaseStringUTFChars(env,hdfFile,file);

&nbsp;&nbsp; if (retVal == FAIL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* check for HDF error */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* for now:&nbsp; use top of exception stack:&nbsp; idealy this
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; should do the whole stack, and analyze the HDF error&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; codes */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errval = HEvalue(1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (errval != DFE_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jc =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*env)->FindClass(env,"ncsa/hdf/HDFLibraryException");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (jc == NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1; /* fatal error is raised by JNI? */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*env)->ThrowNew(env,jc,HEstring(errval));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;
&nbsp;&nbsp; }
&nbsp;&nbsp; else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return retVal;
&nbsp;&nbsp; }

}
</pre>
</td>
</tr>
</table>

<p><b>Figure 18. Example of a native code method that raises exceptions.</b>
<p>
<table BORDER WIDTH="650" >
<tr>
<td>
<pre>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; import ncsa.hdf.*;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HDF h = new HDF();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String theFile = "nosuchfile";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int hid = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hid = h.Hopen(theFile,HDFConstants.DFACC_RDONLY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* do something to recover if possible.... */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(theFile+": "+e.getMessage());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Hopen returned: "+hid);

</pre>
</td>
</tr>
</table>

<p><b>Figure 19. Example of Java code that calls a native method with exception
handling.</b>


<?php
include ("../../../includes/footer.html"); 
?>
